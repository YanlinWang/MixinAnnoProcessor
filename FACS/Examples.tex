\section{Intuitions on formalization}\label{sec:formal}
In this article we dedicate more space to examples and informal presentation and motivations;
so we do not have space to provide a full formalizations.
We will provide here some hints on how the formalization works.

In the following, we present a very simplified grammar:
%\begin{bnf}
%\prodFull{aa}{bb}{Declaration}\\
%\end{bnf}

%\begin{comment}
\begin{bnf}
\prodFull\mTD{\mt\terminalCode{:}\mL \mid \mt\terminalCode{:} \use\ \overline\mV}{Trait Decl}\\
\prodFull\mCD{\mC\terminalCode{:}\mL \mid \mC\terminalCode{:} \use\ \overline\mV}{Class Decl}\\
\prodFull\mV{\mt \mid \mL}{Code Value}\\
\prodFull\mL{
\oC
\Opt{\terminalCode{interface}}\ \terminalCode{implements} \overline\mT\ \overline\mMD
\cC
}{Code Literal}\\
\prodFull\mT{\mC}{types are class names}\\
\prodFull\mMD{\Opt{\terminalCode{class}}\ \terminalCode{method}\ \mT\ \mm\oR\overline{\mT\,\mx}\cR \Opt\me}{Method Decl}\\

\prodFull\me{\mx\mid\mT\mid\me\terminalCode{.}\mm\oR\overline\me\cR}{expressions}\\
\prodFull\mD{\mCD\mid\mTD}{Declaration}\\
\end{bnf}
%\end{comment}

To declare a trait \mTD\ or a class \mCD, we can use either a code literal \mL\ or a trait
expression.  Traits come with various operators (restrict, hide,
alias) but in this work we focus on the single operator 
$\use$, taking a set
of code values: that is trait names \mt\ or literals \mL\ and composing them.  This operation, sometimes called \emph{sum}, is the simplest and most elegant
trait composition operator.  $\use\ \overline\mV$ composes the content of $\overline\mV$
by taking the union of the methods and the union of the implementations.

\use\ can not be applied if multiple versions of the same method are
present in different traits.  An exception is done for abstract methods:
methods where the implementation \me\ is missing. In this case (if the
headers are compatible) the implemented version is selected.  In a sum
of two abstract methods with compatible headers, the one with the more
specific type is selected.

Code literals \mL\ can be marked as interfaces. 
That is, the interface keyword is inside the curly brakets, so an upper case name associated with an interface literal is a class-interface, while a lowercase one is a trait-interface.
In our simple model, we consider an error trying to merge an interface with a non-interface.
 Then we have a set of implemented interfaces and a set of member
  declarations. In this simple language, the only members are methods.
If there are no implemented interfaces, in the concrete syntax we will omit the \Q@implements@ keyword.

Methods \mMD~can be instance methods or \Q@class@ methods. A class method is similar to a \Q@static@ method in Java but can be abstract. This is very usefull in the context of code composition.
To denote a method as abstract, instead of an optional keyword we just omit the implementation \me.

A version of this language where there are no traits can be seen 
as a restriction/variation of FJ~\cite{igarashi2001featherweight}.

\paragraph{Well-formedness}
Basic well formedness rules apply:
\begin{itemize}
\item all method parameters have unique names and the special parameter name \Q@this@ is not declared
 in the parameter list,
\item all methods in a code literal have unique names,
\item all used variables are in scope,
\item all methods in an interface are abstract, and there are no interface class methods.
\end{itemize}
Those rules can be applied on any given \mL~individually and in full isolation.

We expect the type system to enforce: 
\begin{itemize}
\item all the traits and classes have unique names in a program $\overline\mD$, and the special class name
\Q@This@ is reserved,
\item all used types correspond to class declarations in the program, or are \Q@This@, 
\item subtyping between interfaces and classes,
\item method call typechecking,
\item no circular implementation of interfaces,
\item type signature of methods from interfaces can be refined following the well known variant-contravariant rules,
\item only interfaces can be implemented.
\item \marco{I'm sure I'm missing something}
\end{itemize}
While classes are typed assuming \lstinline{this} is of the nominal type of the
class, trait declarations, do not introduce any nominal type.  \lstinline{this}
in a trait is typed with a special type \lstinline{This} that is visible only
inside such trait. Syntactically, \Q@This@ is just a special, reserved, class name $\mC$.
A Literal can use the \lstinline{This} type,
and when flattening completes creating a class definition, \Q@This@ will be replaced with such class name.

For the sake of simplicity, method bodies are just simple expressions
\me: they can be just variables, types and method calls. We need types as part of expressions in order to use them as receivers for class methods.

\begin{comment}
\subsection{Code Use and Code Reuse in \name}

The great absent in our language is the  \Q@extends@ keyword.
In a sense, all classes are final (as in Java).
Moreover  \use\ cannot contain class names.
That is, using a trait is the only way to induce code reuse.

Lets now try to encode the example in Section~\ref{} e in our language:

\begin{lstlisting}
 A:{ method int ma() Utils.m(this) }//note, no {return _}
 Utils:{ class method int m(A a)/*method body here*/ }
\end{lstlisting} 

This code is fine, but there is no way to add a class \Q@B@ reusing
the code of \Q@A@, since
\Q@A@ is designed for code \emph{use} and not \emph{reuse}. Lets try
again, but this time aiming at code reuse:

\begin{lstlisting}
 ta:{ method int ma() Utils.m(this) }//type error
 A:Use ta
 Utils:{ class method int m(A a)/*method body here*/ }
\end{lstlisting}

This does not work, because \lstinline{Utils.m} requires an \lstinline{A} and \lstinline{this} in
\Q@ta@ have no knowlegde of \lstinline{A}. Lets try again

\begin{lstlisting}
 IA:{interface method int ma()}//interface with abstract method
 ta:{implements IA
   method int ma() Utils.m(this) }
 A:Use ta
 Utils:{ class method int m(IA a)/*method body here*/}
\end{lstlisting}

This code works: \Q@Utils@ is using an interface \Q@IA@ and the trait \Q@ta@
is implementing it. It is also possible to add a \Q@B@ as follows
\begin{lstlisting}
  B:Use ta, { method int mb(){return this.ma();} }
\end{lstlisting}
This also works.  \Q@B@ reuses the code of \Q@ta@, but has no knowledge of \Q@A@.
Since \Q@B@ reuses \Q@ta@, and \Q@ta@ implements \Q@IA@, also \Q@B@ implements \Q@IA@. 

\paragraph*{Semantic of Use}
Abeit alternative semantic models for traits~\cite{} have been proposed,
here we use the flattening model.
This means that 
\begin{lstlisting}
A:Use ta
B:Use ta, { method int mb(){return this.ma();} }
\end{lstlisting}
 
  reduces/is equivalent to/is flatted into
  
 \begin{lstlisting}
A:{implements IA method int ma() Utils.m(this) }
B:{implements IA
  method int ma() Utils.m(this)
  method int mb() this.ma() } 

 \end{lstlisting}
 
This code seems correct, and there is no mention of the trait \Q@ta@. In some sense, all the information about code reuse/subclassing is just a private implementation detail of \Q@A@ and \Q@B@; while subtyping is part of the class interface.
\end{comment}


\subsection{Remarks on Typing}
 Our typing discipline is 
what distinguishes our approach from a simple minded code composition macro~\cite{bawden1999quasiquotation}
or a rigid module composition~\cite{ancona2002calculus}.

The are two core ideas:
\paragraph*{1: traits are \emph{well-typed} before being reused.}${}_{}$\\*
 For example in

\begin{lstlisting}
t:{method int m() 2 
   method int n() this.m()+1}
\end{lstlisting}

\noindent \Q@t@ is well typed since \Q@m()@ is declared inside of \Q@t@, while

\begin{lstlisting}
t1:{method int n() this.m()+1} 
\end{lstlisting}
\noindent would be ill typed.

\paragraph*{2: code literals are not required to be \emph{well-typed} before flattening.}${}_{}$\\*
In class expressions  $\use\ \overline\mV$
an \mL\ in $\overline\mV$ is not typechecked before flattening, and only the result is expected to be well-typed.
While this seems a very dangerous approach at first, consider that also Java have the same behaviour:
for example in
\begin{lstlisting}[language=Java]
  class A{ int m() {return 2;}  int n(){return this.m()+1;} }
  class B extends A{ int mb(){return this.ma();} }
\end{lstlisting}

\noindent in \Q@B@ we can call \lstinline{this.ma()} even if in the curly braces there is no declaration for \Q@ma()@.
In our example, using the trait \Q@t@ of before

\begin{lstlisting}
C: Use t {method int k() this.n()+this.m()}
\end{lstlisting}
\noindent would be correct: even if n,m are not defined inside
\Q@{method int k() this.n()+this.m()}@,
the result of the flattening is well typed.

This is not the case in many similar works in literature~\cite{deep,Bettini2015282,Bergel2007} where the
literals have to be self complete. In this case we would have been forced to
declare abstract methods \Q@n@ and \Q@m@.

Our typing strategy has two important properties:
\begin{itemize}
\item If a class is declared by using $\mC : \use\ \overline\mt$, that is, without literals,
and the flattening is successfull, \mC\ is well typed, no need of further checking.
\item On the other side, if a class is declared by $\mC : \use\ \overline\mV$, with
$\mL_1\ldots\mL_n \in \overline\mV$, and after successfull flattening $\mC : \mL$ can not be typechecked,
then the issue was originally present in one of $\mL_1\ldots\mL_n$.
It may be that the result is intrinsically ill-typed, if one of the methods in $\mL_1\ldots\mL_n$ is not well typed,
but it may also happen that a type referred from one of those methods is declared \emph{after} the current class. As we will see later, this is how our relaxation allows to support (indirectly) recursive types.

This also means that as an optimization strategy
 we may remember what method bodies come from traits and what method bodies come from code literals, in order to typecheck only the latter.
 \end{itemize}

 \subsection{Recursive types}

OO languages leverage on recursive types most of the times.
For example in a pure OO language, \Q@String@ may offers a \Q@Int size()@
method, and \Q@Int@ may offer a \Q@String toString()@ method.

This means that is not possible to type in (full) isolation classes
\Q@String@ and \Q@Int@.

The most expressive compilation process may divide the classes in groups of mutually 
dependent classes.
Each group may also depend from a number of other groups.
This would form a Direct Aciclyc Graph of groups.
To type a group, we first need to type all depended groups, then
we can extract the structure/signature/structural type of all
the classes of the group.
Now, with the information of the depended groups and the one extracted
from the current group, it is possible to typecheck the implementation
 of each class in the group.

In this model, it is reasonable to assume that flattening happens group by group, before
extracting the class signatures.

Here we go for a much simpler simple top down execution/interpretation for flattening, where flattening
happen one at the time, and classes are typechecked where their type is first needed.
That is, In our approach typing and flattening interleaves. We assume our compilation process to stop as soon as 
an error arise. There are two main kinds of errors: Type errors (like method not found) or Composition errors (like summing two conflicting implementation for the same method).

For example
\begin{lstlisting}
A:{method int ma(B b) b.mb()+1}
tb:{method int mb() 2}
tc:{method int mc(A a,B b) a.ma(b)}
B: Use tb
C: Use tc, {method int hello() 1}
\end{lstlisting}
In this scenario, since we go top down, we first need to generate \Q@B@.
To generate \Q@B@, we need to use \Q@tb@;
In order to modularly ensure well typedness,
we require \Q@tb@ to be well typed at this stage. If \Q@tb@ was not well typed
a type error could be generated at this stage.
In this moment, \Q@A@ can not be compiled/checked alone,
we need informations about \Q@B@, but \Q@A@ is not used in \Q@tb@,
thus we do not need to type \Q@A@ and we can type \Q@tb@ with
 the available informations and proceed to generate \Q@B@.
Now, we need to generate \Q@C@, and we need to ensure well typedness of \Q@tc@.
Now \Q@B@ is alreay well typed (since generated by \use\ \Q@tb@, with no \mL),
and \Q@A@ can be typed;  finally \Q@tc@ can be typed and used.
If \use\ could not be performed (for example it \Q@tc@ had a method \Q@hello@ too)
a composition error could be generated at this stage.

On the opposite side, if \Q@B@ and \Q@C@ was swapped, as in
\begin{lstlisting}
C: Use tc, {method int hello() 1}  
B: Use tb
\end{lstlisting}

now the first task would be to generate \Q@C@, but 
to type \Q@tc@ we need to know the type of \Q@A@ and \Q@B@.
But they are both unavailable: \Q@B@ is still not computed and 
\Q@A@ can not be compiled/checked alone, without information about \Q@B@.
A type error would be generated, on the line of ``flattening of \Q@C@
requires \Q@tc@, \Q@tc@ requires \Q@A@,\Q@B@, but \Q@B@ is still in need of flattening".

In this example, a more expressive compilation/precompilation process 
could compute a dependency graph and, if possible, reorganize the list,
but for simplicity lets consider to always provide the declarations
in the right order, if one exists.

\paragraph*{Criticism: existence of an order is restrictive.}${}_{}$\\*
Some may find the requirement of the existence of an order restrictive;
An example of a ``morally correct" program where no right order exists is the following:
\begin{lstlisting}
t:{ int mt(A a) a.ma()}
A:Use t {int ma() 1}
\end{lstlisting}

In a system without inference for method types,
if the result of composition operators depends only on the
structural shape of their input (as for \use)
is indeed possible to optimistically compute the resulting structural shape of the classes
and use this information to type involved examples like the former.
We stick to our simple approach, since we believe such typing discipline would be fragile,
and could make human understanding the code-reuse process much harder/involved.
Indeed we just wrote an involved program where the correctness of trait \Q@t@ depends of 
\Q@A@, that is in turn generated using trait \Q@t@.

\paragraph*{Criticism: it would be better to typecheck before flattening.}${}_{}$\\*
In the world of strongly typed languages we could be tempted to
first check that all can go well, and then perform the flattening.
This would however be overcompicated for no observable difference:
Indeed, in the \Q@A,B,C@ example above there is no difference
between
\begin{itemize}
\item  (1)First check \Q@B@ and produce \Q@B@ code (that also contains \Q@B@ structural shape),
  (2) then use \Q@B@ shape to check \Q@C@ and produce \Q@C@ code;\ 
or a more involved
\item  (1)First check \Q@B@ and discover just \Q@B@ structural shape as result of the checking,
  (2)then use \Q@B@ shape to check \Q@C@.
  (3) Finally produce both \Q@B@ and \Q@C@ code.
\end{itemize}

Note that we can reuse code only by naming traits; but our only point of relaxation is {\bf only} the code literal: there is no way an error can ``move around'' and be duplicated during the compilation process.
In particular, our approach allows for safe libraries of traits and classes to be fully typechecked, deployed and reused by multiple clients: no type error will emerge from library code.
On the other side, we do not enforce the programmer to write always self-contained code where all the abstract method definition are explicitly declared.

\begin{comment}
\section{Managing State}
This idea of summing pieces of code is very elegant,
and has proven very successfull in module composition languages~\cite{ancona2002calculus} but our research community is struggling to
make it work with object state (constructor and fields) while acheving the following goals:

\begin{itemize}
\item keep sum associative and commutative,
\item allowing a class to create instances of itself,
\item actually initialize objects, leaving no null fields,
\item managing fields in a way that borrows the elengance of summing methods,
\item make easy to add new fields.
\end{itemize}

In the related work we will show some alternative ways to handle state.
However the purest solution just requires methods:
  The idea is that
  the trait code just uses getter/setters/factories, while leaving
  to classes the role to finally define the fields/constructors.
  That is, the  the class has syntax richer that the trait one,
  allowing declaration for fields and constructors.
  This approach is very powefull~\cite{wang2016classless}
 
\paragraph*{Advantages:} 
this approach is associative and commutative, even self construction
  can be allowed if the trait requires a static/class method
  returning This; the class will then implement this method by forwarding
  a call to the constructor.
  
\paragraph*{Negatives:} writing the class code with the constructors and
   fields and getter/setters and factories can be quite tedious.
   Moreover, there is no way for a trait to specify a default value for a field,
   the class need to handle all the state, even state that is conceptually
   "private" of such trait.

Here in the following an exaple of such approach:

\begin{lstlisting}
  pointSum: { method int x()  method int y()
    class method This of(int x,int y)
    method This sum(This other)
      This.of(this.x+other.x,this.y+other.y)
    }
  pointMul: { method int x() method int y()
    class method This of(int x,int y)
    method This mul(This other)
      This.of(this.x*other.x,this.y*other.y)
    }
\end{lstlisting}

As you see, all the state operations are represented as abstract methods.

\subsection{A First Attempt at Composition}
According to the general ideas expressed before,
\begin{lstlisting}
  Point:Use pointSum,pointMul
\end{lstlisting}  

\noindent would fail since methods \Q@x@,\Q@y@ and \Q@of@ are still abstract.
In this mindset, the user would be required to write something similar to

\begin{lstlisting}
  CPoint:Use pointSum,pointMul, {//not our suggested solution
    int x   int y
    method int x()x   method int y()y
    class method This of(int x, int y)
      new Point(x,y)
    constructor Point(int x, int y){ this.x=x   this.y=y }
    }
\end{lstlisting}

\noindent after a while programming in this style, 
writing those obvious ``close the state'' classes become a
repetivie boring job, and one wonder
if it could be possible to automatically generate such code~\cite{wang2016classless}.
Indeed those classes are just a form of ``fixpoint''.

In our model we go one step further: there is no need to generate code, or to explicitly
write down constructors and fields; there is not even syntax for those
constructor.
The idea is that any class that ``could" be completed in the obvious way
\emph{is a complete ``coherent" class}.
In most other languages, a class is abstract if have abstract methods.
Instead, we call abstract a class whose set of abstract methods is not
coherent, that is, can not be automatically recognized as factory,getters and setters.
  
\paragraph*{Detaild definition of coherent:}
\begin{itemize}
\item a class with no abstract method is coherent, and like Java \Q@Math@.
Will just be usefull for calling class/static methods.
\item a class with a single abstract \Q@class@ method returning \Q@This@
is coherent if all the other abstract methods can be seen as \emph{abstract state
operations} over one of its argument.
For example,
if there is a \Q@class method This of(int x, int y)@ as before,
then
\item a method \Q@int x()@ is intepreted as an abstract state method: a getter for \Q@x@.
\item a method \Q@Void x(int that)@ is a setter for x.
\end{itemize}

While getters and setters are fundamental operations, we can immagine
more operations to be supported; for example
\begin{itemize}
\item \Q@method This withX(int that)@
may be a ``wither", doing a functional field update.
\item \Q@method Void update(int x,int y)@
may do two field update at a time.
\item\Q@method This clone()@ may do a shallow clone of the object.
\end{itemize}

We are not sure what is the best set of abstract state operations yet, but we think this could become a very interesting area of research.
  
  
  lets play with the points of before, to see what good can we do with the current
  instruments:

\begin{lstlisting}
 //same code as before for pointSum and pointMul
  pointSum: { method int x() method int y()
    class method This of(int x,int y)
    method This sum(This other)
      This.of(this.x+other.x,this.y+other.y)
    }
  pointMul: { method int x() method int y()//look we are repeating
    class method This of(int x,int y)//the abstract method declarations.
    method This mul(This other)
      This.of(this.x*other.x,this.y*other.y)
    }
  PointAlgebra:Sum pointSum,pointMul
\end{lstlisting}  

  As you can see, we can declare the methods independently and compose the result
  as we wish. However we have to repeat the abstract methods \Q@x@,\Q@y@ and \Q@of@.
  In addition of \Q@Sum@ and \Q@Mul@ we may want many operations over points; can we improve our reuse
  and not repeat such abstract definitions? of course!

\begin{lstlisting}
  p: { method int x() method int y()
    class method This of(int x,int y)
    }
  pointSum:Use p, { method This sum(This other)
      This.of(this.x+other.x,this.y+other.y)
    }
  pointMul:Use p, { method This mul(This other)
      This.of(this.x*other.x,this.y*other.y)
    }
  pointDiv: ...
  PointAlgebra:Use pointSum,pointMul,pointDiv,...
\end{lstlisting}
      
Now our code is fully modularized, and each trait handle exactly one method.

What happens if we want to add fields instead of just operations?

\begin{lstlisting}
  colored:{ method Color color() }
  Point:Sum pointSum,colored //fails
\end{lstlisting}

This first attempt does not work: the abstract color method
is not a getter for any of the parameters of 
\Q@ class method This of(int x,int y)@
A solution is to provide a richer factory:

\begin{lstlisting}
  CPoint:Use pointSum,colored,{
    class method This of(int x,int y) This.of(x,y,Color.of(/*red*/))
    class method This of(int x, int y,Color color)
    }
\end{lstlisting}

where we assume to support overloading on different parameter number.
This is a good solution, we think is better that any alternatives in literature,
however the method \Q@CPoint.sum@ resets the color to red.
What should be the behaviour in this case?
If we support withers, instead of writing \Q@This.of()@ we can use
\Q@this.withX(newX).withY(newY)@ in order to preserve the color from \Q@this@.
Sadly, if we use this design inside of \Q@sum(This other)@ we would loose the color from \Q@other@.

If the point designer could predict this kind of extension, then we could use the following design:  
\begin{lstlisting}
  p: { method int x() method int y()
    method This withX(int that)
    method This withY(int that)
    static method This of(int x,int y)
    method This merge(This other)
    }
  pointSum:Use p, { method This sum(This other)
      this.merge(other).withX(this.x+other.x).withY(this.y+other.y)
    }
  colored:{method Color color()
    method This withColor(Color that)
    method This merge(This other)
      this.withColor(this.color().mix(that.color())
    }
  CPoint:/*as before*/
\end{lstlisting}  
  Now we can merge colors, or any other kind of state we may want to add
  following this pattern.
  In order to compose, let say \Q@colored@ with \Q@flavored@ we would
  need to compose the merge operation inside of both of them.
  The simple model we are presenting could accomodate this with an
  extension allowing code literals inside of a \use\ expression to use some form of super call to compose conflicting implementations. This is similar to the \emph{override} operation present in the original trait model~\cite{ducasse2006traits}.
\end{comment}
  
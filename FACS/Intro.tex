\section{Introduction}

In mainstream OO languages like Java, C++ or C\# subclassing 
implies subtyping. For example, in Java a subclass definition, such as:

\begin{lstlisting}
class A extends B {}
\end{lstlisting}

\noindent does two things at the same time:
1) {\bf inheriting} code from class \lstinline{B}; and {\bf creating 
a subtype} of \emph{B}. Therefore in a language like Java 
a subclass is \emph{always} a subtype of the extended class.

Historically, there has been a lot of focus on the importance of
separing subtyping from subclassing~\cite{cook}.  This is claimed to be
good for code reuse, design and reasoning. There are at
least two distinct situations where the separation of subtyping and 
subclassing is helpful.

\begin{itemize}

\item {\bf Allowing inheritance/reuse even when subtyping is impossible:} 
In some situations a subclass contains methods whose signatures 
are incompatible with the superclass, yet inheritance is still
possible. A typical example, which was illustrated by Cook et al., are 
classes with \emph{binary methods}~\cite{}.

\item {\bf Preventing unintended subtyping:} For certain classes we
  would like to inherit code without creating a subtype even if, from
  the typing point of view, subtyping is still possible. A typical
  example~\cite{} of this are methods for collection classes such as Sets and
  Bags. Bag implementations can often inherit 
  from Set implementations, and the interfaces of the two collection types are
  similar and type compatible. 
  However, from the logical point-of-view a Bag is \emph{not a
    subtype} of a Set. 

\end{itemize}

Type systems based on structural typing can deal with the first
situation well, but not the second. Since structural subtyping
accounts for the types of the methods only, a Bag would be a subtype
of a Set if the two interfaces are type compatible. For dealing with
the second situation nominal subtyping is preferable. With nominal
subtyping an explicit subtyping relation must be signalled by the
programmer. Thus if subtyping is not desired, the idea is that 
programmer can simply not declare a subtyping relationship.

While there is no problem in subtyping without subclassing, in the design
of most nominal OO languages subtyping implies subtyping in a
fundamental way. This is because of what we call the self-reference
\emph{leaking problem}. The leaking problem is illustrated by the following
(Java) code:

\begin{lstlisting}[language=Java]
  class A{ int ma(){return Utils.m(this);} }
  class Utils{static int m(A a){..}}
\end{lstlisting}

In class \lstinline{A}, the method \lstinline{m} passes \lstinline{this} as \lstinline{A}.
This code seems correct, and there is no subtyping/subclassing.
Now, lets add a class \Q@B@

\begin{lstlisting}[language=Java]
  class B extends A{ int mb(){return this.ma();} }  
\end{lstlisting}

%%Class \lstinline{B} does two things at the same time: 
%%1) it {\bf inherits} the method \lstinline{ma} from
%%\lstinline{A}; and 2) it creates a {\bf subtype} of \lstinline{A}.
We can see an invocation of \lstinline{ma} inside
\lstinline{mb}, where the self-reference \lstinline{this} is of type \lstinline{B}. 
The execution will eventually call \lstinline{Util.m} with an
instance of \lstinline{B}. However, this can be correct only if \lstinline{B} is a subtype of
\lstinline{A}. 

If Java was to support a mechanism to allow reuse/inheritance 
without introducing subtyping, such as:

\begin{lstlisting}[language=Java]
  class B inherits A{ int mb(){return this.ma();} }
\end{lstlisting}

\noindent Then an invocation of 
\lstinline{mb} would be type-unsafe (i.e. it would 
result in a run-time type error). 
Note that here the intention of using the imaginary keyword {\bf
  inherits} is to allow the code from \lstinline{A} to be inherited 
without \lstinline{B} becoming a subtype of \lstinline{A}. 
However this breaks type-safety. The problem is that the
self-reference \lstinline{this} in class \lstinline{B} has 
type \lstinline{B}. Thus, when \lstinline{this} is passed as an argument to 
the method \lstinline{Utils.m} as a result of the invocation of
\lstinline{mb}, it will have a type that is incompatible with the
expected argument of type \lstinline{A}.  
\bruno{
We can also mention what happens in structural types:
"System with structural types would *be required to* guarantee that
the structural type of A is a supertype of the structural type of B‚Äù.
}

What the leaking problem illustrates is that
adopting a more flexible
nominally typed
OO model where subclassing does not imply subtyping is not trivial. 
If we are to separate subclassing from subtyping then a more substantial
change in the language design is necessary.  Every OO language with
the minimal features exposed in the example (using \lstinline{this},
extends and method calls) is forced to accept that subclassing implies
subtyping.\footnote{ Note how this is true also in C++, where is
  possible to "extends privately". Such is a limitation of the
  visibility of subtyping but not over subtyping itself, and the
  former example would be accepted by C++ even if \lstinline{B} was to
  "privately extends" \lstinline{A}.}
In essence we believe that a problem with the design of classes in languages like Java
is that classes do too many things at once. In particular they act
both as units of \emph{use} and \emph{reuse}.
That is, in languages like Java, classes can be
instantiated (using {\bf new}) to create objects that \emph{use} some 
functionality. Classes can also be subclassed to provide \emph{reuse}
of code.  


\marco{Cite some work of bruceTHisType and show how he also fails.}

\begin{comment}
An iconic example on why connecting inheritance/code reuse and
subtpying is problematic is provided by the
historic\cite{LaLonde:1991:SSS:110673.110679}: A reasonable
implementation for a \Q@Set@ may be easy to extend into a \Q@Bag@
keeping tracks of how many times an element occurs.  We would just add
some state and override a couple of methods.\bruno{Are we going to
  present this example in the paper solved in 42, for example? 
I think I would expect to see it.}

However, our subclassing would break Liskov substitution principle (LSP)~\cite{martin2000design}: not all bags are sets!
Of course, one could retroactivelly fix this problem by introducing \Q@AbstractSetOrBag@
and making both \Q@Bag@ and \Q@Set@ inherit from it.
This looks unnatural, since \Q@Set@ would extend it without adding anything,
and we would be surprised to find a use of the type \Q@AbstractSetOrBag@.
Worst, if we was to constantly apply this mentalty, we would introduce a very high number
of abstract classes that are not supposed to be used as types, and that will clutter the 
public interface of our classes and our code project as a whole.
\end{comment}

This paper aims at showing a simple language design, called \name, to
completely decouple subtyping and subclassing in a nominally typed OO
language. The key idea is to divide between code designed for
\textbf{USE} and code designed for \textbf{REUSE}. 
In \name there are two separate concepts: classes
and traits~\cite{}. Classes are meant for code use, and cannot be used
for reuse. In some sense classes in \name are like final classes in
Java. Traits are meant for code reuse and multiple traits can be
composed to form a class which can then be instantiated. Traits 
cannot be instantiated (or used) directly. Such design allows the
subtyping and code reuse to be treated separately, which in terms 
brings several benefits in terms of flexibility and code reuse.
\marco{We need to talk of unanticipated extensions?}
\bruno{Talk more about typing aspects here. Summarize the important 
aspects of the design of \name.}

First we show a minimal language that illustrates the basic ideas. 
Then we show how mutually recursive types
are supported, how state/constructors/fields are supported,
how we can extend the language with nested classes.
Finally we show 42, a full blown language build around our ideas of
reuse.

Our design leverage on traits~\cite{ducasse2006traits}: a well know mechanisms for pure
code reuse.


\subsection{List of contribution}
\marco{text to improve, but is nice to keep a list}
\begin{itemize}
\item simple approach to fully separate inheritance and subtyping
\item easy to grasp model of compilation were typing is late but not
  too late (lazy?)\bruno{this idea is important: it's a key design
    decision. We need to talk about it in the introduction and offer
    some motivation/justification. }
\item clean and elegant handling of state in trat/module composition language
\item extension with nested classes is natural and
  powefull\bruno{wondering if this is necessary. I think there are
    several interesting/novel ideas already. Covering too much will
    result on not saying enough about each individual ideas.}
\item more operators can be accomodated without changing the general model
\end{itemize}

\section{The Design of \name: Separating Use and Reuse}

This section presents the overview of \name, and it illustrates the
key ideas of its design. In particular we illustrate how to separate code use and 
code reuse in \name. %, and how this allows improving both. 

%\subsection{The Design of \name: Decoupling Use from Reuse}

\subsection{Classes in \name: A mechanism for code Use}
%\name has a substantially different design from Java-like languages.
The concept of a class in \name provides a mechanism for code use
only. This means that in \name there is actually no subclassing, and
classes are roughly equivalent to final classes in Java.  Thus,
compared to Java-like languages, the most noticeable difference is the
absence of the \Q@extends@ keyword in \name. 

To illustrate classes in \name consider the example in Section~\ref{}:

\begin{lstlisting}
 A: { method int ma() Utils.m(this) }//note, no {return _}
 Utils:{ class method int m(A a)/*method body here*/ }
\end{lstlisting} 

\noindent Classes in \name use a slightly different declaration style compared
to Java. In \name there is no \lstinline{class} keyword. 
Class declarations have a name (which must always start with
an uppercase letter) and a code literal, which is used to specify the
definitions of the class. For instance, in the class declaration
for \lstinline{A}, the name of the class is \lstinline{A} and the code 
literal associatted with the class (\Q@{ method int ma()   Utils.m(this) }@) contains the definitions associated to the
class. There are, however, some 
important differences to Java-like languages in the way 
classes and code-literals are type-checked, as we shall see next. 
Nevertheless, for this example, things still work in a similar way to Java. 

The \name code above is fine, but there is no way to add a class 
\Q@B@ reusing the code of \Q@A@, since
\Q@A@ is designed for code \emph{use} and not \emph{reuse}. So, unlike
the Java code, introducing a subclass
\lstinline{B} is not possible. At first, this may seem like a severe restriction, but
\name has a different mechanism for code \emph{reuse} that 
is more appropriate when code reuse is intended. 

\subsection{Traits in \name: A mechanim of code Reuse}

Unlike classes traits in \name cannot be instantiated and do not introduce new
types. However they provide code reuse.
%So, lets try again encoding the code for the leaking problem, but this
%time aiming at code reuse. 
Trait declarations 
look very much like class declarations, but trait names 
start with a lowercase letter. An obvious first attempt 
to model the example in Section~\ref{} (for a Java programmer) 
with traits and code reuse is:

\begin{lstlisting}
 ta:{ method int ma() Utils.m(this) }//type error
 A:Use ta
 Utils:{ class method int m(A a)/*method body here*/ }
\end{lstlisting}

\noindent Here \lstinline{ta} is a trait intended to replace the
original class \lstinline{A} so that the code of the method
\lstinline{ma} can be reused. Then the class \lstinline{A} 
is created by inheriting the code from the trait using the keyword 
{\bf Use}. Note that \use\ cannot contain class names: only trait
names are allowed.
That is, using a trait is the only way to induce code reuse.
Unfortunatelly, this code does not work, 
because \lstinline{Utils.m} requires an \lstinline{A} and the type of \lstinline{this} in
\Q@ta@ has no relationship to the type \lstinline{A}.
Since the trait name is not a type, no code external to that trait can
refer to it. This is one of the key design decisions in \name. 
The point is that the trait can refer to the program via \lstinline{this}, but the
program is agnostic to what the trait type is going to be, so it can
be later assigned to any (or many) classes. This improves the
flexibility of reuse as illustrated in Section~\ref{}. However, 
to solve the more immediate typing issue above we need one more
round of refactoring, as we shall see next. 


%: in \name all declarations 
%are sequentially type-checked and if a definition occurs afterwards
%another, then it is not visible on all previous definitions.

\paragraph{Type of the self-reference} The code above does not work
because the way type-checking works in \name is that type-checking of 
code literals is independent of the class/trait names associated to
it. A Java programmer may expect that the type of \lstinline{this} 
in the previous definition of \lstinline{ta} is \lstinline{ta}
itself. However, this intuition brought from Java is wrong in \name
for two reasons:

\begin{itemize}

\item The first reason is that {\bf traits are not types}. Traits in
  \name are simply units of reuse and cannot be used as types. Types
  are only introduced by class/interface declarations.

\item The second reason is that {\bf the type of self-references is the self type of the
    code literal.} Unlike Java-like languages, where the body of a
  class declaration is intrinsically coupled with the class itself, in
  \name code literals are first-class\bruno{Is it appropriate to say
    that they are first class?} and are type-checked independently.
  \name has a notion of self-type, which is closely related to
  approaches such as ThisType~\cite{} and ...\cite{others}. Therefore
  in \name the self-reference does not have the type of the class
  being defined, but rather it has the self-type.
\end{itemize}

With this in mind, we can try to model the example in Section~\ref{} again:

\begin{lstlisting}
 IA:{interface method int ma()}//interface with abstract method
 Utils:{ class method int m(IA a)/*method body here*/}
 ta:{implements IA
   method int ma() Utils.m(this) }
 A:Use ta
\end{lstlisting}

This code works: \Q@Utils@ is using an interface \Q@IA@ and the trait \Q@ta@
is implementing it. Thus the self-type of the trait \Q@ta@ (and the
type of \lstinline{this}) will be a
subtype of \Q@IA@. It is also possible to add a \Q@B@ as follows
\begin{lstlisting}
  B:Use ta, { method int mb(){return this.ma();} }
\end{lstlisting}
This also works.  \Q@B@ reuses the code of \Q@ta@, but has no knowledge of \Q@A@.
Since \Q@B@ reuses \Q@ta@, and \Q@ta@ implements \Q@IA@, also \Q@B@ implements \Q@IA@. 

\paragraph*{Semantic of Use}
Albeit alternative semantic models for traits~\cite{} have been proposed,
here we use the flattening model.
This means that 
\begin{lstlisting}
A:Use ta
B:Use ta, { method int mb(){return this.ma();} }
\end{lstlisting}
 
\noindent reduces/is equivalent to/is flatted into
  
 \begin{lstlisting}
A:{implements IA method int ma() Utils.m(this) }
B:{implements IA
  method int ma() Utils.m(this)
  method int mb() this.ma() } 

 \end{lstlisting}
 
 This code seems correct, and there is no mention of the trait
 \Q@ta@. In some sense, all the information about code
 reuse/subclassing is just a private implementation detail of \Q@A@
 and \Q@B@; while subtyping is part of the class interface.

\begin{figure}[t]
\begin{center}
\begin{tabular}{c|c|c|c}
              & Instantiable (Use) & Unit of Reuse & Introduces New Type \\
\hline
Class  & Yes              & No          & Yes           \\
Trait   & No               & Yes         & No            \\
\end{tabular}
\end{center}
\caption{A comparision between traits and classes in \name.}
\label{fig:compare}
\end{figure}

To finish this section, Figure \ref{fig:compare} provides a summary of
the differences between classes and traits. The comparison focus on
the roles of traits and classes with respect to instantiation,
reusability and whether the declarations also introduce new types or
not.

\section{Improving Use by Preventing Unintended Subtyping}
%%Preventing Unintended Subtyping}
As stated in Section~\ref{} a possible benefit of a nominally typed OO language
that separates inheritance from subtyping is that it is possible to 
have reuse, while preventing unintended subtyping. The design of \name 
allows this, thus it \emph{improves the use} of classes, while
retaining the benefits of reuse when compared to Java-like languages. 
Here we illustrate this benefit by modelling a simplified version of
Set and Bag collections. 

\bruno{Plan: Show simplified Java code. Show how the Java code forces
  us to make Bags a subtype of Set, if we want reuse. 
Then show the 42/language in this paper/ code and solution.  
}

An iconic example on why connecting inheritance/code reuse and
subtpying is problematic is provided by the
historic\cite{LaLonde:1991:SSS:110673.110679}: A reasonable
implementation for a \Q@Set@ may be easy to extend into a \Q@Bag@
keeping tracks of how many times an element occurs.  We would just add
some state and override a couple of methods.\bruno{Are we going to
  present this example in the paper solved in 42, for example? 
I think I would expect to see it.}

However, our subclassing would break Liskov substitution principle (LSP)~\cite{martin2000design}: not all bags are sets!
Of course, one could retroactivelly fix this problem by introducing \Q@AbstractSetOrBag@
and making both \Q@Bag@ and \Q@Set@ inherit from it.
This looks unnatural, since \Q@Set@ would extend it without adding anything,
and we would be surprised to find a use of the type \Q@AbstractSetOrBag@.
Worst, if we was to constantly apply this mentalty, we would introduce a very high number
of abstract classes that are not supposed to be used as types, and that will clutter the 
public interface of our classes and our code project as a whole.

\begin{lstlisting}
class Set {.../* Elem put() boolean isIn(Elem)*/ ...}
class Bag extends Set{.../*override something to keep track of duplications*/..}
\end{lstlisting}

but now, 

\begin{lstlisting}
Set mySet=new Bag(); //OK for the type system but not for LSP
\end{lstlisting}

as a pleasaruble accident, avoid such code gift us simple support for
This type and (in the extensions with nested classes seen later)
family polimporphism.

\section{Improving Reuse when Subtyping is Impossible}

\name retains the ability to allow reuse even when subtyping is
impossible. That is, in some situations a subclass contains methods
whose signatures are incompatible with the superclass, yet inheritance
is still possible. This type of situations is the primary motivator
for previous work aiming at separating inheritance from subtyping, and
it happens, for example, in classes with \emph{binary
  methods}~\cite{}.  Despite the adoption of a nominal approach and
unlike other nominally typed languages, the leaking problem does not
prevent \name from enjoying such kind of improved reuse.

To illustrate how \name allows for improved reuse, we consider a
pattern to combine \emph{multiple trait inheritance} and \emph{state}:
a challenging problem that has limited the flexibility of traits and
reuse in the past.

\subsection{Managing State}

This idea of summing pieces of code is very elegant, and has proven
very successfull in module composition
languages~\cite{ancona2002calculus}\bruno{and several trait models?}. 
However our research community is
struggling to make it work with object state (constructor and fields)
while acheving the following goals:

\begin{itemize}
\item keep sum associative and commutative,
\item allowing a class to create instances of itself,
\item actually initialize objects, leaving no null fields,
\item managing fields in a way that borrows the elegance of summing methods,
\item make it easy to add new fields.
\end{itemize}

In the related work we will show some alternative ways to handle state.
However the purest solution just requires methods:
  The idea is that
  the trait code just uses getter/setters/factories, while leaving
  to classes the role to finally define the fields/constructors.
  That is, the  the class has syntax richer that the trait one,
  allowing declaration for fields and constructors.
  This approach is very powefull~\cite{wang2016classless}
 
\paragraph*{Advantages:} 
this approach is associative and commutative, even self construction
  can be allowed if the trait requires a static/class method
  returning This; the class will then implement this method by forwarding
  a call to the constructor.
  
\paragraph*{Negatives:} writing the class code with the constructors and
   fields and getter/setters and factories can be quite tedious.
   Moreover, there is no way for a trait to specify a default value for a field,
   the class need to handle all the state, even state that is conceptually
   "private" of such trait.

Here in the following an example of such approach:

\begin{lstlisting}
  pointSum: { method int x()  method int y()
    class method This of(int x,int y)
    method This sum(This other)
      This.of(this.x+other.x,this.y+other.y)
    }
  pointMul: { method int x() method int y()
    class method This of(int x,int y)
    method This mul(This other)
      This.of(this.x*other.x,this.y*other.y)
    }
\end{lstlisting}

As you see, all the state operations are represented as abstract methods.

\subsection{A First Attempt at Composition}
According to the general ideas expressed before,
\begin{lstlisting}
  Point:Use pointSum,pointMul
\end{lstlisting}  

\noindent would fail since methods \Q@x@,\Q@y@ and \Q@of@ are still abstract.
In this mindset, the user would be required to write something similar to

\begin{lstlisting}
  CPoint:Use pointSum,pointMul, {//not our suggested solution
    int x   int y
    method int x()x   method int y()y
    class method This of(int x, int y)
      new Point(x,y)
    constructor Point(int x, int y){ this.x=x   this.y=y }
    }
\end{lstlisting}

\noindent after a while programming in this style, 
writing those obvious ``close the state'' classes become a
repetivie boring job, and one wonder
if it could be possible to automatically generate such code~\cite{wang2016classless}.
Indeed those classes are just a form of ``fixpoint''.

In our model we go one step further: there is no need to generate code, or to explicitly
write down constructors and fields; there is not even syntax for those
constructor.
The idea is that any class that ``could" be completed in the obvious way
\emph{is a complete ``coherent" class}.
In most other languages, a class is abstract if have abstract methods.
Instead, we call abstract a class whose set of abstract methods is not
coherent, that is, can not be automatically recognized as factory,getters and setters.
  
\paragraph*{Detaild definition of coherent:}
\begin{itemize}
\item a class with no abstract method is coherent, and like Java \Q@Math@.
Will just be usefull for calling class/static methods.
\item a class with a single abstract \Q@class@ method returning \Q@This@
is coherent if all the other abstract methods can be seen as \emph{abstract state
operations} over one of its argument.
For example,
if there is a \Q@class method This of(int x, int y)@ as before,
then
\item a method \Q@int x()@ is intepreted as an abstract state method: a getter for \Q@x@.
\item a method \Q@Void x(int that)@ is a setter for x.
\end{itemize}

While getters and setters are fundamental operations, we can immagine
more operations to be supported; for example
\begin{itemize}
\item \Q@method This withX(int that)@
may be a ``wither", doing a functional field update.
\item \Q@method Void update(int x,int y)@
may do two field update at a time.
\item\Q@method This clone()@ may do a shallow clone of the object.
\end{itemize}

We are not sure what is the best set of abstract state operations yet, but we think this could become a very interesting area of research.
  
  
  lets play with the points of before, to see what good can we do with the current
  instruments:

\begin{lstlisting}
 //same code as before for pointSum and pointMul
  pointSum: { method int x() method int y()
    class method This of(int x,int y)
    method This sum(This other)
      This.of(this.x+other.x,this.y+other.y)
    }
  pointMul: { method int x() method int y()//look we are repeating
    class method This of(int x,int y)//the abstract method declarations.
    method This mul(This other)
      This.of(this.x*other.x,this.y*other.y)
    }
  PointAlgebra:Sum pointSum,pointMul
\end{lstlisting}  

  As you can see, we can declare the methods independently and compose the result
  as we wish. However we have to repeat the abstract methods \Q@x@,\Q@y@ and \Q@of@.
  In addition of \Q@Sum@ and \Q@Mul@ we may want many operations over points; can we improve our reuse
  and not repeat such abstract definitions? of course!

\begin{lstlisting}
  p: { method int x() method int y()
    class method This of(int x,int y)
    }
  pointSum:Use p, { method This sum(This other)
      This.of(this.x+other.x,this.y+other.y)
    }
  pointMul:Use p, { method This mul(This other)
      This.of(this.x*other.x,this.y*other.y)
    }
  pointDiv: ...
  PointAlgebra:Use pointSum,pointMul,pointDiv,...
\end{lstlisting}
      
Now our code is fully modularized, and each trait handle exactly one method.

What happens if we want to add fields instead of just operations?

\begin{lstlisting}
  colored:{ method Color color() }
  Point:Sum pointSum,colored //fails
\end{lstlisting}

This first attempt does not work: the abstract color method
is not a getter for any of the parameters of 
\Q@ class method This of(int x,int y)@
A solution is to provide a richer factory:

\begin{lstlisting}
  CPoint:Use pointSum,colored,{
    class method This of(int x,int y) This.of(x,y,Color.of(/*red*/))
    class method This of(int x, int y,Color color)
    }
\end{lstlisting}

where we assume to support overloading on different parameter number.
This is a good solution, we think is better that any alternatives in literature,
however the method \Q@CPoint.sum@ resets the color to red.
What should be the behaviour in this case?
If we support withers, instead of writing \Q@This.of()@ we can use
\Q@this.withX(newX).withY(newY)@ in order to preserve the color from \Q@this@.
Sadly, if we use this design inside of \Q@sum(This other)@ we would loose the color from \Q@other@.

If the point designer could predict this kind of extension, then we could use the following design:  
\begin{lstlisting}
  p: { method int x() method int y()
    method This withX(int that)
    method This withY(int that)
    static method This of(int x,int y)
    method This merge(This other)
    }
  pointSum:Use p, { method This sum(This other)
      this.merge(other).withX(this.x+other.x).withY(this.y+other.y)
    }
  colored:{method Color color()
    method This withColor(Color that)
    method This merge(This other)
      this.withColor(this.color().mix(that.color())
    }
  CPoint:/*as before*/
\end{lstlisting}  
  Now we can merge colors, or any other kind of state we may want to add
  following this pattern.
  In order to compose, let say \Q@colored@ with \Q@flavored@ we would
  need to compose the merge operation inside of both of them.
  The simple model we are presenting could accomodate this with an
  extension allowing code literals inside of a \use\ expression to use some form of super call to compose conflicting implementations. This is similar to the \emph{override} operation present in the original trait model~\cite{ducasse2006traits}.
  



\section{Old: Self Types, Binary Methods and the Need to Separate
  Inheritance from Subtyping}

So, far it appears that we have not gained much from decoupling
reuse from subtyping.

As discussed in Section~\ref{} the type of the self-reference is the
self-type. Like languages with ThisType, \name allows explicit
references to the self type. This is useful in several situations: 
For example it can be helpful in the presence of binary
methods~\cite{}, or methods that return an instance of the 
class being defined. 




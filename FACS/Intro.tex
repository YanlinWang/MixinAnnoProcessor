\section{Introduction}

Historically, we have seen a lot of focus on the importance of
separing subtype from subclassing~\cite{cook}.  This is claimed to be
good for code reuse, design and reasoning.  While there is no problem
in subtyping without subclassing, in most OO languages code reuse
(inheritance/extends) imply subtyping.  Consider the following (Java)
code:

\begin{lstlisting}[language=Java]
  class A{ int ma(){return Utils.m(this);} }
  class Utils{static int m(A a){..}}
\end{lstlisting}

This code seems correct, and there is no subtyping/subclassing.
Now, lets add a class \Q@B@

\begin{lstlisting}[language=Java]
  class B extends A{ int mb(){return this.ma();} }
\end{lstlisting}

Class \lstinline{B} now have a method \lstinline{ma} inherited from \lstinline{A}.
This method passes \lstinline{this} as \lstinline{A}; we can see an invocation of \lstinline{ma}
inside \lstinline{mb}, where \lstinline{this} is of type \lstinline{B}.
The execution will eventually call \lstinline{Util.m} with a \lstinline{B} instance.
This can be correct only if \lstinline{B} is a subtype of \lstinline{A}.
Thus, every OO language with the minimal features 
exposed in this example (using this, extends, method call)
is forced to accept that subclassing implies subtyping.\footnote{
Note how this is true also in C++, where is possible to
"extends privately". Such is a limitation of the visibility of
subtyping but not over subtyping itself, and the former example
would be accepted by C++ even if \lstinline{B} was to "privately extends" \lstinline{A}.}
\marco{Cite some work of bruceTHisType and show how he also fails.}
\bruno{I was expecting some text/argument here on why subclassing
  implies subtyping is bad. Perhaps another example where subclassing 
must not imply subtyping to type-check.}
An iconic example on why connecting inheritance/code reuse and subtpying is problematic is
provided by the historic\cite{LaLonde:1991:SSS:110673.110679}:
A reasonable implementation for a \Q@Set@ may be easy to extend into a \Q@Bag@ keeping tracks of how many times an element occurs.
We would just add some state and override a couple of methods.

However, our subclassing would break LSP[]: not all bags are sets!
Of course, one could retroactivelly fix this problem by introducing \Q@AbstractSetOrBag@
and making both \Q@Bag@ and \Q@Set@ inherit from it.
This looks innatural, since \Q@Set@ would extend it without adding anything,
and we would be surprised to find a use of the type \Q@AbstractSetOrBag@.
Worst, if we was to constantly apply this mentalty, we would introduce a very high number
of abstract classes that are not supposed to be used as types, and that will clutter the 
public interface of our classes and our code project as a whole.

We will show here a simple design to completley uncouple subtyping
and subclassing in a nominally typed OO language,
by dividing code designed for \textbf{USE}
from code designed for \textbf{REUSE}.\footnote{We need to talk of unanticipated extensions?}
First we show a minimal language, then we show how mutually recursive types
are supported, how state/constructors/fields are supported,
how we can extend the language with nested classes.
Finally we show 42, a full blown language build around our ideas of reuse.

Our design leverage on traits~\cite{}: a well know mechanisms for pure
code reuse


\subsection{List of contribution}
\marco{text to improve, but is nice to keep a list}
\begin{itemize}
\item simple approach to fully separate inheritance and subtyping
\item easy to grasp model of compilation were typing is late but not too late (lazy?)
\item clean and elegant handling of state in trat/module composition language
\item extension with nested class is natural and powefull
\item more operators can be accomodated without changing the general model
\end{itemize}

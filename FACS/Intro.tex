\section{Introduction}

In mainstream OO languages like Java, C++ or C\# subclassing 
implies subtyping. For example, in Java a subclass definition, such as:

\begin{lstlisting}
class A extends B {}
\end{lstlisting}

\noindent does two things at the same time:
1) {\bf inheriting} code from class \lstinline{B}; and {\bf creating 
a subtype} of \emph{B}. Therefore in a language like Java 
a subclass is \emph{always} a subtype of the extended class.

Historically, there has been a lot of focus on the importance of
separing subtyping from subclassing~\cite{cook}.  This is claimed to be
good for code reuse, design and reasoning. There are at
least two distinct situations where the separation of subtyping and 
subclassing is helpful.

\begin{itemize}

\item {\bf Allowing inheritance/reuse even when subtyping is impossible:} 
In some situations a subclass contains methods whose signatures 
are incompatible with the superclass, yet inheritance is still
possible. A typical example, which was illustrated by Cook et al., are 
classes with \emph{binary methods}~\cite{}.

\item {\bf Preventing unintended subtyping:} For certain classes we
  would like to inherit code without creating a subtype even if, from
  the typing point of view, subtyping is still possible. A typical
  example~\cite{} of this are methods for collection classes such as Sets and
  Bags. Bag implementations can often inherit 
  from Set implementations, and the interfaces of the two collection types are
  similar and type compatible. 
  However, from the logical point-of-view a Bag is \emph{not a
    subtype} of a Set. 

\end{itemize}

Type systems based on structural typing can deal with the first
situation well, but not the second. Since structural subtyping
accounts for the types of the methods only, a Bag would be a subtype
of a Set if the two interfaces are type compatible. For dealing with
the second situation nominal subtyping is preferable. With nominal
subtyping an explicit subtyping relation must be signalled by the
programmer. Thus if subtyping is not desired, the idea is that 
programmer can simply {\bf not} declare a subtyping relationship.

While there is no problem in subtyping without subclassing, in the design
of most nominal OO languages subtyping implies subtyping in a
fundamental technical way. This is because of what we call the
\emph{this leaking problem}, illustrated by the following
(Java) code:

\begin{lstlisting}[language=Java]
  class A{ int ma(){return Utils.m(this);} }
  class Utils{static int m(A a){..}}
\end{lstlisting}

Method \lstinline{A.ma} passes \lstinline{this} as \lstinline{A} to \Q@Util.m@.
This code seems correct, and there is no subtyping/subclassing.
Now, lets add a class \Q@B@

\begin{lstlisting}[language=Java]
  class B extends A{ int mb(){return this.ma();} }  
\end{lstlisting}

%%Class \lstinline{B} does two things at the same time: 
%%1) it {\bf inherits} the method \lstinline{ma} from
%%\lstinline{A}; and 2) it creates a {\bf subtype} of \lstinline{A}.
We can see an invocation of \lstinline{A.ma} inside
\lstinline{B.mb}, where the self-reference \lstinline{this} is of type \lstinline{B}. 
The execution will eventually call \lstinline{Util.m} with an
instance of \lstinline{B}. However, this can be correct only if \lstinline{B} is a subtype of
\lstinline{A}. 

%If Java was to support a mechanism to allow reuse/inheritance 
%without introducing subtyping, such as:
%
%\begin{lstlisting}[language=Java]
%  class B inherits A{ int mb(){return this.ma();} }
%\end{lstlisting}
%
%\noindent Then an invocation of 
%\lstinline{mb} would be type-unsafe (i.e. it would 
%result in a run-time type error). 
%Note that here the intention of using the imaginary keyword {\bf
%  inherits} is to allow the code from \lstinline{A} to be inherited 
%without \lstinline{B} becoming a subtype of \lstinline{A}. 
%However this breaks type-safety. The problem is that the
%self-reference \lstinline{this} in class \lstinline{B} has 
%type \lstinline{B}. Thus, when \lstinline{this} is passed as an argument to 
%the method \lstinline{Utils.m} as a result of the invocation of
%\lstinline{mb}, it will have a type that is incompatible with the
%expected argument of type \lstinline{A}.  

If in Java code reuse was not introducing subtyping an invocation of 
\lstinline{B.mb} would result in a run-time type error.
The problem is that the
self-reference \lstinline{this} in class \lstinline{B} has 
type \lstinline{B}. Thus, when \lstinline{this} is passed as an argument to 
the method \lstinline{Utils.m} as a result of the invocation of
\lstinline{mb}, it will have a type that is incompatible with the
expected argument of type \lstinline{A}.  



Every OO language with the minimal features exposed in the example (using \lstinline{this},
extends and method calls) is forced to accept that subclassing implies
subtyping.\footnote{ Note how this is true also in C++, where is
  possible to "extends privately". Such is a limitation of the
  visibility of subtyping but not over subtyping itself, and the
  former example would be accepted by C++ even if \lstinline{B} was to
  "privately extends" \lstinline{A}.}
  
In essence we believe that a problem with the design of classes in languages like Java
is that classes do too many things at once. In particular they act
both as units of \emph{use} and \emph{reuse}.
That is, in languages like Java, class names can be
\emph{use}d as type and instantiated.
Classes can also be subclassed to provide \emph{reuse}
of code.  

Adopting a more flexible nominally typed OO model where subclassing does not imply subtyping is not trivial,
and a more substantial change in the language design is necessary.


This paper aims at showing a simple language design, called \name, to
completely decouple subtyping and subclassing in a nominally typed OO
language. The key idea is to divide between code designed for
\textbf{USE} and code designed for \textbf{REUSE}. 
In \name there are two separate concepts: classes
and traits~\cite{}. Classes are meant for code use, and cannot be used
for reuse. In some sense classes in \name are like final classes in
Java. Traits are meant for code reuse and multiple traits can be
composed to form a class which can then be instantiated. Traits 
cannot be instantiated (or used) directly. Such design allows the
subtyping and code reuse to be treated separately, which in turn
brings several benefits in terms of flexibility and code reuse.
%\marco{We need to talk of unanticipated extensions?}
%\bruno{Talk more about typing aspects here. Summarize the important 
%aspects of the design of \name.}

First we show a minimal language that illustrates the basic ideas. 
Then we show how mutually recursive types
are supported, how state/constructors/fields are supported,
how we can extend the language with nested classes.
Finally we show 42, a full blown language build around our ideas of
reuse.

Our design leverage on traits~\cite{ducasse2006traits}: a well know mechanisms for pure
code reuse.


\subsection{List of contribution}
\marco{text to improve, but is nice to keep a list}
\begin{itemize}
\item simple approach to fully separate inheritance and subtyping
\item easy to grasp model of compilation were typing is late but not
  too late (lazy?)\bruno{this idea is important: it's a key design
    decision. We need to talk about it in the introduction and offer
    some motivation/justification. }
\item clean and elegant handling of state in trat/module composition language
\item extension with nested classes is natural and
  powefull\bruno{wondering if this is necessary. I think there are
    several interesting/novel ideas already. Covering too much will
    result on not saying enough about each individual ideas.}
\item more operators can be accomodated without changing the general model
\end{itemize}





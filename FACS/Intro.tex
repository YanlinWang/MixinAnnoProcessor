\section{Introduction}

Historically, there has been a lot of focus on the importance of
separing subtype from subclassing~\cite{cook}.  This is claimed to be
good for code reuse, design and reasoning.  While there is no problem
in subtyping without subclassing, in most OO languages code reuse
(inheritance/extends) implies subtyping in a fundamental way. 
Consider the following (Java) code:

\begin{lstlisting}[language=Java]
  class A{ int ma(){return Utils.m(this);} }
  class Utils{static int m(A a){..}}
\end{lstlisting}

In class \lstinline{A}, the method \lstinline{m} passes \lstinline{this} as \lstinline{A}.
This code seems correct, and there is no subtyping/subclassing.
Now, lets add a class \Q@B@

\begin{lstlisting}[language=Java]
  class B extends A{ int mb(){return this.ma();} }
\end{lstlisting}

Class \lstinline{B} inherits the method \lstinline{ma} from
\lstinline{A}.  We can see an invocation of \lstinline{ma} inside
\lstinline{mb}, where \lstinline{this} is of type \lstinline{B}.  The
execution will eventually call \lstinline{Util.m} with a \lstinline{B}
instance. This can be correct only if \lstinline{B} is a subtype of
\lstinline{A}. Thus, every OO language with the minimal features
exposed in this example (using \lstinline{this}, extends and method calls) is forced
to accept that subclassing implies subtyping.\footnote{ Note how this
  is true also in C++, where is possible to "extends privately". Such
  is a limitation of the visibility of subtyping but not over
  subtyping itself, and the former example would be accepted by C++
  even if \lstinline{B} was to "privately extends" \lstinline{A}.}
\marco{Cite some work of bruceTHisType and show how he also fails.}
\bruno{I was expecting some text/argument here on why subclassing
  implies subtyping is bad. Perhaps another example where subclassing
  must not imply subtyping to type-check.} 

An iconic example on why connecting inheritance/code reuse and
subtpying is problematic is provided by the
historic\cite{LaLonde:1991:SSS:110673.110679}: A reasonable
implementation for a \Q@Set@ may be easy to extend into a \Q@Bag@
keeping tracks of how many times an element occurs.  We would just add
some state and override a couple of methods.\bruno{Are we going to
  present this example in the paper solved in 42, for example? 
I think I would expect to see it.}

However, our subclassing would break Liskov substitution principle (LSP)~\cite{martin2000design}: not all bags are sets!
Of course, one could retroactivelly fix this problem by introducing \Q@AbstractSetOrBag@
and making both \Q@Bag@ and \Q@Set@ inherit from it.
This looks unnatural, since \Q@Set@ would extend it without adding anything,
and we would be surprised to find a use of the type \Q@AbstractSetOrBag@.
Worst, if we was to constantly apply this mentalty, we would introduce a very high number
of abstract classes that are not supposed to be used as types, and that will clutter the 
public interface of our classes and our code project as a whole.

This paper aims at showing a simple language design to completley uncouple subtyping
and subclassing in a nominally typed OO language. The key idea is to
divide between code designed for \textbf{USE}
and code designed for \textbf{REUSE}.\marco{We need to talk of unanticipated extensions?}
First we show a minimal language that illustrates the basic ideas. 
Then we show how mutually recursive types
are supported, how state/constructors/fields are supported,
how we can extend the language with nested classes.
Finally we show 42, a full blown language build around our ideas of
reuse.

Our design leverage on traits~\cite{ducasse2006traits}: a well know mechanisms for pure
code reuse.


\subsection{List of contribution}
\marco{text to improve, but is nice to keep a list}
\begin{itemize}
\item simple approach to fully separate inheritance and subtyping
\item easy to grasp model of compilation were typing is late but not
  too late (lazy?)\bruno{this idea is important: it's a key design
    decision. We need to talk about it in the introduction and offer
    some motivation/justification. }
\item clean and elegant handling of state in trat/module composition language
\item extension with nested classes is natural and
  powefull\bruno{wondering if this is necessary. I think there are
    several interesting/novel ideas already. Covering too much will
    result on not saying enough about each individual ideas.}
\item more operators can be accomodated without changing the general model
\end{itemize}

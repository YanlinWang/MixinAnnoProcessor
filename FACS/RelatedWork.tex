\section{Extensions and practical experience}
The model presented here is very easy to extend:
For example nested classes can be easly added,giving us enough power to easly solve the expression problem as in \cite{deepfjig}. More composition operators can be added in addition to use. Indeed
we just need to be sure that every newly added operator respects the following criteria:

\begin{itemize}
\item As for \use, the operato does not need to be total, but if it fails it needs to provide an error that will be reported to the programmer.
\item When the operator takes in input only traits (they are going to be well typed), if a result is produced,
 such result is well typed.
\item When the operator takes in input also code literal, if a non well typed result is produced,
the type error must be tracked back to code in one of those non typed yet code literals.
 \end{itemize}
 That is, our model can easly support all the operators of \cite{deep}.
 
 
 Our simplified model represent the conceptual core of  a novel programming language (http://L42.is)
 we are currently working at.
 L42 contains the extensions described before and much more, and provide a concrete example of the usability of our model.
 
 The main difference is that code literal are first class values in L42, thus we do not need traits as a language concept, but just as a method returning such code literal.
 
 
 
\section{Related Work}
The literature on code reuse is too vast to let us do justice of it in a fiew pages,
Our work is clearly inspired on Traits~\cite{ducasse2006traits}; they are in turn insipired on module composition languages~\cite{ancona2002calculus}
and multiple inheritance~\cite{}.

\subsection{Inheritance and subtyping}

We are aware of at least 3 independently designed research languages 
that address this limitation:Delta-Trait(DT)\cite{ferruccioworks}, Package Template(PT)\cite{}, DeepFjig\cite{}.
Leveraging on \emph{traits}, in this work we aim to synthesizes
the main ideas of those very different language designs.

\begin{itemize}
\item deep+ {\bf A simple uniform syntax for code literals}
DeepFjig is best in this sense, since DT have separate syntax for class literals, trait literals and record literals.
PT on the other side build on top of full Java, thus has a very involved syntax.
Thanks to our novel represantation of state, our approach offers a much simpler and uniform syntax then
all others, where evertyhing is basically just a method.
\item deep-
{\bf Reusable code can not be ``used'', that is instantiated or used as a type.}
This happens in DT and in PT, but not in DeepFjig. To allow reusable code to be directly 
usable, in DeepFjig
classes introduce nominal types in an innatural way: the type of \Q@this@ is only \Q@This@ (sometimes called \Q@<>@) and not the nominal type of its class: that is in DeepFjig 
\Q@A:{ method A m()this}@ is not well typed. This is because
\Q@B: Use A@ flattens to \Q@B:{ method A m()this}@, that is clearly not well typed.
Looking to this example is clear why we need reusable code to be agnostic of its name.
Then, either reusable code have no name (DT, PT and this work)
or all code is reusable and usable, and all code need to be auckwardly agnostic of its name.

\item PT+
{\bf Requiring abstract signatures is a left over of module composition mindset.}
DT and Deepfjig comes form a tradition of functional module composition, where 
modules are typed in isolation under an environments, and then the composition is performed.
As we show in this work, this is ends up requiring verbose repetition of abstract signatures, 
that for hightly modularized code may end up composing most of the program.
Simple Java (and thus PT, since it is an add on over Java) show us a better way:
the meaning of names can be understood from the reuse context.
The typing strategy of PT offers the same advantages of our typing model, 
but is more involved and indirect. This may be caused by the
heavy task of integrating with full Java.
\item PT-{\bf Composition algebra.}
The idea of using composition operators over atomic values as in an arithmetic expression is very powerfull,
and makes easy to extend languages with more operators. Deepfjig and DT embrace this idea, while PT takes the traditional Java/C++ approach of using enhanced class/package declaration syntax.
The typing strategy of PT also seams to be connected with this decision, so it would be hard to move their approach in a composition algebra setting.
\item DT- {\bf Naming your type, even if you have none yet.}
Both Deepfjig and PT allows a class to refer to its name, abait is more unobvious in PT since you have to introduce both a package and a classes to express it.
This allows to encode binary methods, express patterns like withers or fluent setters and to instantiate instances of the (future) class(es)  using the reused code.
\item DT+{\bf Complete ontological separation between use and reuse}
While all 3 works allows to separate inheritance and subtyping only DT properly enforce 
separation between use (classes and interfaces) and reuse (traits).
This is because in DeepFjig all classes are both units of use and reuse (however, subtype is not induced)
and PT imports all the complexity of Java, so abait is possible to separate use and reuse, the model have powerfull but unobvous implications where (conventional Java) \Q@extends@ and PT are used together

\end{itemize}
With the exception of those 3 lines of work, to the best of our understading
other famous work in literature, like~\cite{odersky2008programming,nystrom2006j}
does no completly break the relation between inheritance and subtyping, but only prevent subtyping only where 
it would be unsound.

\subsection{State and traits}

The idea of abstract state operation has emerged from CJ~\cite{wang2016classless}, and offer a clean solution to handling state
in a trait composition setting.
Note how abstract state operation are different from just hiding fields under getter and setters: 
in our model the programmer simply never declare what is the state of the class, not even what information is stored in fields.
The state is computed by the system as an overall result of the whole code composition process.

In literature there has been many attempts to add state in traits/module composition languages.
\begin{itemize}  
\item No constructor: all the fields start at null/a default specified value.
  Fields are just like another kind of (abstract) member, and two fields
  with identical type can be merged by sum/use; \Q@new C()@ can be used for all classes, and \Q@init@ methods may be called later, as in
  \Q@Point p=new Point(); p.init(10,30)@.
  
  To its credit, this simple approach is commutative and associative and do not disrupt elegance of summing methods.
  However, objects are created "broken" and the user is trusted with fixing them.
  While is easy to add fields, the load of inizializing them is on the user; moreover
    all the objects are intrinsically mutable, so this model is unfriendly
    to a functional programming style.
\item Constructor compose fields:
In this approach (used by \cite{FJig}) the fields are declared but not initialized, and
a canonical constrctor constructor (as in FJ) taking a value for each field and just initializing such field
is automatically generated in the resulting class.

It is easy to add fields, however this model is associative but not commutative: composition order influence field order, and thus the construtor signature.
Self construction is not possible 
since the signature of the constuctor change during composition.

\item Constructor can be composed if they offers the same exact parameters:
In this approach (used by DeepFJig) traits declare field and constructors.
The constructor initialize the fields but can do any other computation.
Traits whose constructors have the same signature can be composed.
The composed constructor will execute both constructor bodies in order.

This approach is designed to allows Self construction.
It is also associative and mostly commutative: composition order only influence execution order of side effects during construction.
However constructors composition requires identical constructor signature: this
hamper reuse, and if a field is added, its initial value need to be
somehow syntetized from the constructor parameters.

\end{itemize}

%\item extension with nested class is natural and powefull
%We claim that our solution to the expression problem is the most natural in literature to date:
%While a similar sintax can be achieved with the scandinavian style~\cite{ernst2004expression}, their dependent type system makes reasoning quite complex, and indeed more recent solutions have accepted a more involved syntax in order to have an understandable type system~\cite{igarashi2005lightweight}.

%Our close contendant is DeepFJig~\cite{corradi2011deepfjig}: all our gain over their model is based on our relaxation over abstract signatures.
%Note how we solve the expression problem in the most radical way possible \marco{bruno, here you can insert some of the criticism over expression problem trivially and explain how is not applicable to us here.}

%Add that: original trait model has no self construction and types introduction not relevant since dynamicly typed language

\subsection{Tablular comparision of many approaches}
\begin{minipage}[t]{0.4\textwidth}
In this table we show if some approach or part-there-of support certain critical features:
Direct instantation (as in \Q@new C()@),
Self instantiation (as in \Q@new This()@),
Unit of use, Unit of reuse,
Introduce type and if the Induced type is the type of \Q@this@,
support for binary methods,
does inheritance induce subtype?,
is code required to be well-typed before being inherited /imported in a new context?
is code required to be well-typed before composed with other code?

We use Y and X to mean yes and no, and we use ``-'' were the question is not really applicable to the current approach. For example the original trait model was untyped, so typing questions makes little sense.
\end{minipage}
%second column
\begin{minipage}[t]{0.6\textwidth}
${}_{}$
\begin{center}
\begin{tabular}{c|c|c|c|c|c|c|c|c|c|c}
&\Rotated{direct instantation}
&\Rotated{self instantiation}
&\Rotated{unit of use}
&\Rotated{unit of reuse}
&\Rotated{introduce type}
&\Rotated{induced type is this type}
&\Rotated{binary methods}
&\Rotated{inheritance induce subtype}
&\Rotated{well-typed before imported}
&\Rotated{well-typed before composed} 
\\
\hline
java/scala class&Y&X&Y&Y&Y&Y&X&Y&Y&X\\
java8 interface &X&X&X&Y&Y&Y&X&Y&Y&X\\
scala trait        &X&X&X&Y&Y&Y&X&Y&X&X\\
original trait     &X&X&X&Y&-&-&X&X&-&-\\
Ferruccio trait  &X&X&X&Y&X&-&X&X&Y&Y\\
\name trait            &X&Y&X&Y&X&-&Y&X&Y&X\\
\name class           &Y&Y&Y&X&Y&Y&Y&-&Y&X\\
module composition
                      &-&-&Y&Y&-&-&-&-&Y&Y\\
deepFJig class &Y&Y&Y&Y&Y&X&Y&X&Y&Y\\
package template
                      &X&Y&X&Y&X&-&X&X&Y&X\\

\end{tabular}
\end{center}
\end{minipage}

\bruno{
We can also mention what happens in structural types:
"System with structural types would *be required to* guarantee that
the structural type of A is a supertype of the structural type of B‚Äù.
}


\marco{Cite some work of bruceTHisType and show how he also fails to separe reuse and use}

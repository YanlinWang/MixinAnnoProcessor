\section{Extensions and practical experience}
The model presented here is very easy to extend:
For example nested classes can be easly added,giving us enough power to easly solve the expression problem as in \cite{deepfjig}. More composition operators can be added in addition to use. Indeed
we just need to be sure that every newly added operator respects the following criteria:

\begin{itemize}
\item As for \use, the operato does not need to be total, but if it fails it needs to provide an error that will be reported to the programmer.
\item When the operator takes in input only traits (they are going to be well typed), if a result is produced,
 such result is well typed.
\item When the operator takes in input also code literal, if a non well typed result is produced,
the type error must be tracked back to code in one of those non typed yet code literals.
 \end{itemize}
 That is, our model can easly support all the operators of \cite{deep}.
 
 
 Our simplified model represent the conceptual core of  a novel programming language (http://L42.is)
 we are currently working at.
 L42 contains the extensions described before and much more, and provide a concrete example of the usability of our model.
 
 The main difference is that code literal are first class values in L42, thus we do not need traits as a language concept, but just as a method returning such code literal.
 
 
 
\section{Related Work}
The literature on code reuse is too vast to let us do justice of it in a fiew pages,
Our work is clearly inspired on Traits~\cite{ducasse2006traits}; they are in turn insipired on module composition languages~\cite{ancona2002calculus}
and multiple inheritance~\cite{}.

We are aware of at least 3 independently designed research languages 
that address this limitation:Delta-Trait(DT)\cite{3ferruccio works}, Package Template(PT)\cite{}, DeepFjig\cite{}.
Leveraging on \emph{traits}, in this work we aim to synthesizes
the main ideas of those very different language designs.

\begin{itemize}
\item deep+ {\bf A simple uniform syntax for code literals}
DeepFjig is best in this sense, since DT have separate syntax for class literals, trait literals and record literals.
PT on the other side build on top of full Java, thus has a very involved syntax.
Thanks to our novel represantation of state, our approach offers a much simpler and uniform syntax then
all others, where evertyhing is basically just a method.
\item deep-
{\bf Reusable code can not be ``used'', that is instantiated or used as a type.}
This happens in DT and in PT, but not in DeepFjig. To allow reusable code to be directly 
usable, in DeepFjig
classes introduce nominal types in an innatural way: the type of \Q@this@ is only \Q@This@ (sometimes called \Q@<>@) and not the nominal type of its class: that is in DeepFjig 
\Q@A:{ method A m()this}@ is not well typed. This is because
\Q@B: Use A@ flattens to \Q@B:{ method A m()this}@, that is clearly not well typed.
Looking to this example is clear why we need reusable code to be agnostic of its name.
Then, either reusable code have no name (DT, PT and this work)
or all code is reusable and usable, and all code need to be auckwardly agnostic of its name.

\item PT+
{\bf Requiring abstract signatures is a left over of module composition mindset.}
DT and Deepfjig comes form a tradition of functional module composition, where 
modules are typed in isolation under an environments, and then the composition is performed.
As we show in this work, this is ends up requiring verbose repetition of abstract signatures, 
that for hightly modularized code may end up composing most of the program.
Simple Java (and thus PT, since it is an add on over Java) show us a better way:
the meaning of names can be understood from the reuse context.
The typing strategy of PT offers the same advantages of our typing model, 
but is more involved and indirect. This may be caused by the
heavy task of integrating with full Java.
\item PT-{\bf Composition algebra.}
The idea of using composition operators over atomic values as in an arithmetic expression is very powerfull,
and makes easy to extend languages with more operators. Deepfjig and DT embrace this idea, while PT takes the traditional Java/C++ approach of using enhanced class/package declaration syntax.
The typing strategy of PT also seams to be connected with this decision, so it would be hard to move their approach in a composition algebra setting.
\item DT- {\bf Naming your type, even if you have none.}
Both Deepfjig and PT allows a class to refer to its name, abait is more unobvious in PT and is unclear 
...
\item DT+ real separation use-reuse

\end{itemize}

Our idea of fully separate inheritance and subtyping has some precedence
In all the line of work of Ferruccio [cite many] neither traits nor classes introduce nominal types,
that are provided only by interfaces.
In DeepFjig[] classes introduce nominal types but in an innatural way, the type of \Q@this@ is only \Q@This@ (sometimes called \Q@<>@) and not the nominal type of its class: that is in DeepFjig 
\Q@A:{ method A m()this}@ is not well typed.

Other work cite~\cite{odersky2008programming,nystrom2006j}
do no completly break the relation between inheritance and subtyping, but only prevent subtyping where 
it would be unsound.

Our compilation model is a clear step forward with respect to 
\cite[metaFjig, deepFjig,myThesis,allferruccioWorkBefore2017], where all code was required to declare all the abstract dependencies all of the time.

%\item clean and elegant handling of state in trat/module composition language
The idea of abstract state operation has emerged from CJ~\cite{wang2016classless}, and offer a clean solution to handling state
in a trait composition setting.
Note how abstract state operation are different from just hiding fields under getter and setters: 
in our model the programmer simply never declare what is the state of the class, not even what information is stored in fields.
The state is computed by the system as an overall result of the whole code composition process.

In literature there has been many attempts to add state in traits/module composition languages.
\begin{itemize}  
\item No constructor: all the fields start at null/a default specified value.
  In this model fields are like another kind of member, and two fields
  with identical type can be merged by sum; \Q@new C()@ can be used for all classes, and \Q@init@ method may be called later, as in
  \Q@Point p=new Point(); p.init(10,30)@.
  
  To its credit, this simple approach is commutative and associative and do not disrupt elegance of summing methods.
  However, objects are created "broken" and the user is trusted with fixing them.
  While is easy to add fields, the load of inizializing them is on the user; moreover
    all the objects are intrinsically mutable, so this model is unfriendly
    to a functional programming style.
\item Constructor compose fields:
In this approach the fields are declared but not initialized, and
a canonical constrctor constructor taking a value for each field and just initializing such field
is automatically generated in the resulting class.

In this approach it is easy to add fields, however this approach is associative but not commutative, since the order of composition will change the order of the fields; moreover there is no support for self construction
since the signature of the constuctor change during composition.

\item Constructor can be composed if they offers the same exact parameters:
In this approach traits declare field and constructors.
The constructor initialize the fields but can do any other computation.
Traits whose constructors have the same signature can be composed.
The composed constructor will execute both constructor bodies in order.

This approach is designed to allows Self construction.
It is also associative and mostly commutative: the order of composition is relevant only
in the order of execution of side effects during construction.
However the requirement that the constructors need the same parameters 
hamper reuse, and if a field is added, its initial value need to be
somehow syntetized from the old constructor parameters.

\end{itemize}

%\item extension with nested class is natural and powefull
We claim that our solution to the expression problem is the most natural in literature to date:
While a similar sintax can be achieved with the scandinavian style~\cite{ernst2004expression}, their dependent type system makes reasoning quite complex, and indeed more recent solutions have accepted a more involved syntax in order to have an understandable type system~\cite{igarashi2005lightweight}.

Our close contendant is DeepFJig~\cite{corradi2011deepfjig}: all our gain over their model is based on our relaxation over abstract signatures.
Note how we solve the expression problem in the most radical way possible \marco{bruno, here you can insert some of the criticism over expression problem trivially and explain how is not applicable to us here.}

Add that: original trait model has no self construction and types introduction not relevant since dynamicly typed language


\bruno{
We can also mention what happens in structural types:
"System with structural types would *be required to* guarantee that
the structural type of A is a supertype of the structural type of B‚Äù.
}


\marco{Cite some work of bruceTHisType and show how he also fails to separe reuse and use}

Separating use and reuse to improve both //(title from bruno)

Abstract

Introduction






Managing State



  Extensions to our model
  One of the main feature of our simple reuse/use model is that it can be
  easly extended.

  Nested classes and expression problem
  a nested class will be another kind o member in the Literal, so  

M::= class? method T m(Txs) e? | CD
T::= C| C.T //now types are paths

The general idea is that with sum, nested classes with the same name are recursivelly composed.
Note that while we have nested classes, we do not have nested traits: all traits are still
at top level.
Untypable/unresolved Traits are also the only "dependency"
the type system keeps track of, this means that when a nested class at an arbirary
nested level is flattend, as in
C:{ D:{ E:Sum t1,t2,L}}
t1 and t2 must be defined before C and ad top level, and they may require classes (and their
nested) defined before C. This means that the type system can still consider
the class table as a simple map from Types T to ...  

now we can easily encode the expression problem:


exp:{Exp:{interface}}
lit:Sum exp,{ Lit:{implements Exp 
    class method This of(int inner);
    method int inner();}
  }
sum:Sum exp,{ Sum:{implements Exp 
    class method This of(Exp left, Exp right);
    method Exp left(); method Exp right();}
  }  
uminus:Sum exp,{ UMinus:{implements Exp 
    class method This of(exp inner);
    method Exp inner();}
  }   
expToS:{Exp:{interface method String toString()}}
sumToS:Sum sum,expToS,{ Sum:{implements Exp
    method String toString()
      left.toString()+"+"+right.toString();
  }
uminusToS:...
then just sum all you need

MySolution:Sum sumToS,litToS

More expression problem: transformer method: lets add 1 to all literals
expAdd1:{Exp:{interface method Exp add1()}}
sumAdd1:Sum sum,expAdd1,{Sum:{implements Exp
    method Exp add1()
      Sum.of(left.add1,right.add1());
  }
litAdd1:Sum lit,expAdd1,{Lit:{implements Exp
    method Exp add1()
      Lit.of(inner()+1);
    }
  
MySolutionAdd1:Sum sumToS,litToS,sumAdd1,litAdd1

Notice how if we wished to add many similar operations we would 
have to repeat the propagation code (as in sumAdd1) many times
just changing the name of the operation. We show later how to avoid this.


------------------------------ 
More operators:

Sum is amazing, elegant and simple, but the system can be enriched with more 
operators:
The idea is that there is no need of a fixed set of operators,
every operator just have to respect the following criteria:
if starts form well typed code, it produces well typed code.
TODO: tell what happens when summing interfaces+classes
---------
Restrict make abstract method

--------
Rename, like refactoring
Rename can invoke sum inside
---------
Redirect, like generics
Redirect can be multiple.

With redirect+rename we can have the general operator propagator
 
operation:{//for sum and lit, easy to extends as before
  T:{}
  Exp:{interface method Exp op(T x)}}
  Sum:Sum sum,{ extends Exp sum,expAdd1,{
    method Exp op(T x)
      Sum.of(left.op(x),right.op(x));
    }
  Lit:Sum lit,{
    method Exp op(T x)
      this;
  }
Now, to have my addN I can
opAddn: Sum
  operation[redirect T to Int]
    [rename Exp.op(x) to addN(x)][restrict Lit.op(x)], {
  Lit:{method Exp addN(Int x) Lit.of(inner())+x}
  }
  
Full power of redirect

serviceCombinator:{ S:{implements Service
  method R report()
  }
  
  R:{method R combine(R that)
    class method R empty()}
  
  ListS:list[redirect Elem to S]
  
  class R method(ListS ss){//here we use extended java like syntax
    R r=R.empty()
    for(S s in ss){
      s.performService();
      r=r.combine(s.report())
      }
    return r;
  }
}
PaintingService:serviceCombinator[redirect S to Painting.Service]

To encode the former generic code in java you need to write
the following headeche inducing interfaces for RService and Report (and still we miss the empty method)
and require that the services you want to serve implement those.
  interface Service{ void performService();}
  interface Report<R extends Report<R>>{R combine(R that);}
  interface RService<R extends Report<R>> extends Service{ R report();}

---------------------
Road to 42:

  In the model we have presented we have iterative compilation,
  in the sense that flattening and type checking alternates.
  What if flattening could execute arbitrary computation?
  This would subsume the need for a main expression!
  
  e::=x|T|e.m(es)|L
  CD::=C:e
  T::=Cs | Library | Class
  and a trait will just be encoded as a class with a single method:
  Trait1:{class method Library code() L1 }
  Composition operators are now supported by some classes:
  Sum.of(e1,e2)
  Rename.of(...)
  and we can have a Resource(L) operator
  that just wrap the L into a method, so that
  Trait1:Resource(L1) will reduce in the trait pattern as before.
  
  Now typing is a little harder....
  
  ----------
  In addition to this, 42 have feature less related to code composition, like
  a strong type system supporting aliasing mutability and circularity control,
   checked exceptions, errors (unchecked exceptions), strong exception safety
   for errors ... 
  a compact syntax for arithmentic and list operations,
  allowing overloading and a much nicer syntax for code composition
  as ....
  
  42 is also strongly against primitive types/classes, thus there is no such
  thing as a predefined standard library or a nicer sintax for certains special 
  classes like String and numbers.
  The idea is that any program will start importing a library, called Towel,
  that contains the classes that are usually expected from a standard library.
  And the programmers are encouraged to develop their own version of towels.
  
  This would be crazy in any language not supporting the level of code reuse
  42 offers:
  From one side, developing your own standard library would be a massive amount
  of work, and from the other side, libraries developed using a certain towel 
  would not be compatible with any other towel.
  However, the level of code reuse offered by 42 solves both limitations:
  You can obtain your own Towel by staining/embrowdering another Towel.
  You can load a library deployed by other towels.
  
  Lets dig in how this mechanism can work
  
  
  After, show Use.hide/Use.extends
  
  This form of disciplined metaprogramming
  is more likly to produce semantically reasonable results w.r.t.
  full ast generation metaprogramming/ quote unquote metaprogramming.
  
  This is because the atomic steps are operations 
  designed to be understandable and meaningful for the human metaprogrammer,
  and because such operators can not introduce any new type error.
  
  This disciplined metaprogramming is not very limited, as one may expect;
  indeed is possible to generate arbitrary behaviour out of inductive reasoning:
  example: generate toS.
  -base: case one field
  -step: merge two fields
  -wrap the final result
   
   
  
  


  
  
  
  
  ListP:{inteface
    method int size()
    method Person get(int index)
    method void set(int index,Person value) 
    }
  baseList:{implements ListI...}
  map:{implements ListI
    method Bool geq(Person p1,Person p2)
    method This sort(){..use geq..}}
  
  MyList:Sum baseList,map,{ method Bool geq(Person p1,Person p2) p1.age()>p2.age() }


-----------------------------------------
examples of attempts of constructors/state in traits:
   

  No constructor: all the fields start at null/a default specified value.
  In this model fields are like another kind of member, and two fields
  with identical type can be merged by sum.
  
  In this model, you can write new C() for all classes, and
  you may be required to call and init method later, as in
  new Point().init(10,30).
  pro: commutative/associative, do not disrupt elegance of sum methods.
  negatives: objects are created "broken" and the user is trusted with fixing them
    easy to add fields, but the load of inizializing them is on the user; moreover
    all the objects are intrinsically mutable, so this model is unfriendly
    to a functional programming style.
  /*
  for example, in the usual Point/ColoredPoint example,
  a point trait could look like
  point: { int x=0; int y=0
  method This initXY(int x,int y){this.x=x;this.y=y;return this;}
  method This sum(This other){
    return new This().initXY(this.x+other.x,this.y+other.y);}
  }
  and a CPoint class just adding a color could look like
  colored:{ Color color=new Color().init(/*red*/);}
  CPoint:Use point,colored
  CPoint:{ int x=0; int y=0;Color color=new Color().init(/*red*/);
    method This initXY(int x,int y){this.x=x;this.y=y;return this;}
    method This sum(This other){
      return new This().initXY(this.x+other.x,this.y+other.y);}
    }
  Where summing points leave the color to red, without giving any warning
  to the programmer composing point and colored.
*/  
  
constructor compose fields:
In this approach the fields are declared but not initialized, and
a constructor taking a value for each field and just initializing such field
is automatically generated in the resulting class.
Pro: it is easy to add fields.
Negatives:This approach is associative but not commutative, since the order of composition
will change the order of the fields, there is no support for self construction
more that declaring a static abstract factory as before.
  
Constructor can be composed if they offers the same parameters.
In this approach traits declare field and constructors
and the constructor initialize the fields, and can do any other computation.
In order to sum two traits, we need their constructors to have the same 
parameters with the same order. Then the composed constructor will execute
both constructor bodies in order.
Pro: it is associative and "mostly" commutative: the order of composition is relevant only
in the order of execution of side effects during construction.
Self construction is easy in this model.
Negative: the requirement that the constructors need the same parameters 
hamper reuse, and if a field is added, its initial value need to be
syntetized from the old constructor parameters.

-----------------------------

Our proposed solution:
We like the extreame 

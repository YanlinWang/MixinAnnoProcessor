\section{Improving Use by Preventing Unintended Subtyping}

%As stated in Section~\ref{} 
To have code-reuse, while preventing unintended subtyping
in a nominally typed OO language we need to
 separates inheritance from subtyping.

Thus, \name  \emph{improves the use} of classes, while
retaining the benefits of code-reuse when compared to Java-like languages. 
Here we illustrate this benefit by modelling a simplified version of
Set and Bag collections. 

\paragraph{Set/Bag broken solution}
An iconic example on why connecting inheritance/code reuse and
subtpying is problematic is provided by the
historic\cite{LaLonde:1991:SSS:110673.110679}: A reasonable
implementation for a \Q@Set@ may be easy to extend into a \Q@Bag@
keeping tracks of how many times an element occurs.  We would just add
some state and override a couple of methods.
For example in Java one could have

\begin{lstlisting}
class Set {...//usual hashmap implementation
  private Elem[] hashMap;
  Elem put() /*body*/
  boolean isIn(Elem)/*body*/
  ...}
class Bag extends Set{...//for each element in the hash map,
  private int[] countMap;// keep track of how many times is there
  @Override Elem put()/*body*/
  int howManyTimes(Elem)/*body*/
  ...}\end{lstlisting}

Coding \Q@Bag@ in this way can avoid a lot of code duplication, but we induced unintented subtyping: indeed

\begin{lstlisting}
Set mySet=new Bag(); //OK for the type system but not for LSP
\end{lstlisting}
Since Subclassing implies subtyping, our code break Liskov substitution principle (LSP)~\cite{martin2000design}: not all bags are sets!

\paragraph{Set/Bag fixed solution still broken}
Of course, one could retroactivelly fix this problem by introducing \Q@AbstractSetOrBag@
and making both \Q@Bag@ and \Q@Set@ inherit from it:
\begin{lstlisting}
abstract class AbstractSetOrBag{/*old set code goes here*/}
class Set extends AbstractSetOrBag{} //empty body? just repeat constructors?
class Bag extends AbstractSetOrBag{/*old bag code goes here*/}
..
AbstractSetOrBag unexpected=new Bag(); //AbstractSetOrBag type not designed to be used.
\end{lstlisting}

This looks unnatural, since \Q@Set@ would extend \Q@AbstractSetOrBag@ without adding anything,
and we would be surprised to find a use of the type \Q@AbstractSetOrBag@.
Worst, if we was to constantly apply this mentalty, we would introduce a very high number
of abstract classes that are not supposed to be used as types, and that will clutter the 
public interface of our classes and our code project as a whole.
In our example now the information \Q@Set<:AbstractSetOrBag@ is present in the public interface
of the class \Q@Set@, but is not needed to use the class properly.

Moreover, we have not really solved the original problem but only moved it further away. For example: one day  we may need bags that can only store up to 5 copies of the same element.
We are now at the starting point again:
\begin{itemize}
\item either we inser \Q@class Bag5 extends Bag@ and we break LSP,
\item we duplicate the code of the \Q@Bag@ implementation with minimal adjustments in \Q@class Bag5 extends AbstractSetOrBag@
\item or we introduce a
\Q@abstract class BagN extends AbstractSetOrBag@ and \Q@class Bag5 extends BagN@
and we modify \Q@Bag@ so that  \Q@class Bag extends BagN@.
Note that this last solution is changing the public interface of the formerly released \Q@Bag@ class, and
this may even break retro-compatibility (if a client program was using reflection in a poor way)
\end{itemize}

\paragraph{Set/Bag in \name}
Instead, in our proposed approach, if we was to originally declare
\begin{lstlisting}
Set:{/*set implementation*/} 
\end{lstlisting}
Then our code would be impossible to reuse in the first place for any user of our library.
We consider this an advantage, since unintended code reuse runs into underdocumented behaviour near all of the times\footnote{See
``Design and document for inheritance or else prohibit it''\cite{https://www.infoq.com/articles/API-Design-Joshua-Bloch}:
self use of public methods is rarelly documented, thus is hard to understand the effects of overriding a library metod\cite{https://www.infoq.com/articles/API-Design-Joshua-Bloch}.
}

If the designer of the set class wishes to make it reusable, it can do it explicitly by providing a set trait:
\begin{lstlisting}
set:{/*set implementation*/} 
Set:Use set
\end{lstlisting}
Notice how since \Q@set@ can never be used as a type, there is no reason to give it a fancy-future-aware name like
\Q@AbstractSetOrBag@.
When bag will be added, the code will look either like
\begin{lstlisting}
set:{/*set implementation*/} 
Set:Use set
Bag: Use set, {/*bag implementation*/}
\end{lstlisting}
or 
\begin{lstlisting}
set:{/*set implementation*/} 
Set:Use set
bag: Use set, {/*bag implementation*/}
Bag: Use bag
\end{lstlisting}
Notice how, thanks to flattening, the resulting code for \Q@Bag@ is identical in both versions, thus if we are the developers of bags, we can temporarly go for the first version, and move when needed to the second without adding new undesired complexity for our old clients. 


%As a pleasaruble accident, avoid such code gift us simple support for
%This type and (in the extensions with nested classes seen later)
%family polimporphism.


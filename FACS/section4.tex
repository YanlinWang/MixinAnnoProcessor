\section{Improving Reuse}
\name allows reuse even when subtyping is impossible.
In \name traits do not induce a new (externally visible) type.
However, locally in the trait the programmer can use the special self-type \Q@This@ in order to denote the 
type of \Q@this@.
That is: the program is agnostic to what the \Q@This@ type is going to be, so it can
be later assigned to any (or many) classes. 
The idea is that during flattening, \Q@This@ will be replaced with the actual class name.
In this way, \name allows reuse even when subtyping is
impossible, that is, when a method parameter has type \Q@This@ (also called \emph{binary
  methods}~\cite{bruce96binary}). 
This type of situations is the primary motivator
for previous work aiming at separating inheritance from subtyping.
Leveraging on the \Q@This@ type, we can also provide self-instantiation (trait methods can create instances of the class using them) and smootly integrate state and traits: a challenging problem that has limited the flexibility of traits and
reuse in the past.
%First we show how self-instantiation and state are already avaible in the simplest trait model,
%then we show how to radically improve the 

\subsection{Managing State}

To illustrate how \name improves reuse, we will show a novel approach
to deal with \emph{state} in traits.  The idea of summing pieces of
code is very elegant, and has proven very successfull in module
composition languages~\cite{ancona2002calculus} and several trait
models~\cite{Traits:ECOOP2003,Bergel2007,BETTINI2013521,DBLP:journals/iandc/LagorioSZ12}.  However the research
community is struggling to make it work with object state (constructor
and fields) while achieving the following goals:

%\begin{itemize}
%complicated discussions on this point \item keep sum associative and commutative,
%\item
(1) managing fields in a way that borrows the elegance of summing methods;
%\item
(2) actually initialize objects, leaving no null fields;
%\item
(3) making it easy to add new fields;
%\item
(4) allowing a class to create instances of itself.
%\end{itemize}

In the related work we will show some alternative ways to handle
state.  However the purest solution just requires methods. The idea is
that the trait code just uses getter/setters/factories, while leaving
to classes the role to finally define the fields/constructors. That
is, the class has syntax richer that the trait one, allowing
declaration for fields and constructors.  This approach is very
powerful as illustrated by Wang et al.~\cite{wang2016classless}.

\paragraph{Immutable Points} Consider, for example, two simple 
traits that deal with \emph{immutable point} objects. That is, points
in the cartesian plane (with coordinates \lstinline{x} and
\lstinline{y}). The first trait provides a \emph{binary method} that 
sums the point object with another point to return a new point. 
The second trait provides a similar operation that does multiplication 
instead.
 
\begin{lstlisting}
  pointSum: { method int x()  method int y()//getters
    class method This of(int x,int y)//factory method
    method This sum(This that)
      This.of(this.x()+that.x(),this.y()+that.y())//self instantiation
    }
  pointMul: { method int x() method int y()//repeating getters
    class method This of(int x,int y)//repeating factory
    method This mul(This that)
      This.of(this.x()*that.x(),this.y()*that.y())
    }
\end{lstlisting}

\noindent As we can see, all the state operations (the getters for the 
\lstinline{x} and \lstinline{y} coordinates) are represented as {\bf abstract} methods.
Notice the abstract \Q@class method This of(..)@ which acts as a constructor
for points:
A class method is similar to a \Q@static@ method in Java but can be abstract. 
As for instance methods, they are late bound:  flattening can provide an implementation for them.
abstract class method are very similar to the original concept of member functions in the module composition setting.

\subsection{A First Attempt at Composition}
According to the general ideas about trait composition presented in
Section~\ref{sec:separate}, a first attempt at composing the two traits providing
two different operations on points is:
\begin{lstlisting}
  Point:Use pointSum,pointMul
\end{lstlisting}  

\noindent However this fails since methods \Q@x@,\Q@y@ and \Q@of@ are still abstract!
Instead a user could write something similar to:

\begin{lstlisting}
  CPoint:Use pointSum,pointMul, {//not our suggested solution
    int x   int y
    method int x() x       
    method int y() y
    class method This of(int x, int y) new Point(x,y)
    constructor Point(int x, int y){ this.x=x   this.y=y }
    }
\end{lstlisting}
\bruno{We talk about withers later on. So I think we should consider
  having withers in this code, so that readers can understand what 
withers are!}
\marco{with withers it will look more complicated}

\noindent This approach works, and it as some advantages, but also
some disadvantages: 

\begin{itemize}

\item {\bf Advantages:} This approach is associative and commutative, even self construction
  can be allowed if the trait requires a static/class method
  returning \Q@This@. The class will then implement the methods returning \Q@This@
  by forwarding a call to the constructor.
  
\item {\bf Disadvantages:} Writing those obvious definitions to close
  the state/fixpoint in the class 
   with the constructors and fields and getter/setters and factories can be quite tedious.
   %Moreover, there is no way for a trait to specify a default value for a field,
   %the class need to handle all the state, even state that is conceptually
   %"private" of such trait. 
   Previous work shows that such code can be automatically generated~\cite{wang2016classless}.

\end{itemize}

\subsection{The \name approach to State}

In our model we go one step further: there is no need to generate
code, or to explicitly write down constructors and fields. In fact in
\name there is not even syntax for those constructs!  The idea is that
any class that ``can" be completed in the obvious way  is \emph{a
  complete ``coherent" class}.  In most other languages, a class is
abstract if it has abstract methods.  Instead, we call a class
abstract only when the set of abstract methods is not coherent. That
is, the unimplemented methods cannot not be automatically recognized
as factory, getters and setters. Methods recognized as factory, getters and setters are called
\emph{abstract state operations}.
  
\paragraph*{Coherent classes} A more detailed definition of coherent
classes is given next:
\begin{itemize}
\item a class with no abstract methods is coherent (just like Java
  \Q@Math@, for example). Such classes are useful for calling class/static methods.
\item a class with a single abstract \Q@class@ method returning \Q@This@
is coherent if all the other abstract methods can be seen as \emph{abstract state
operations} over one of its argument.
For example,
if there is a \Q@class method This of(int x, int y)@ as before,
then
\begin{itemize}
\item a method \Q@int x()@ is interpreted as an abstract state method: a \emph{getter} for \Q@x@.
\item a method \Q@Void x(int that)@ is a \emph{setter} for x.
\end{itemize}
\end{itemize}

While getters and setters are fundamental operations, we can immagine
more operations to be supported; for example:
\begin{itemize}
\item \Q@method This withX(int that)@
may be a ``wither", doing a functional field update: it creates a new instance that is like \Q@this@ but where field \Q@x@ has now \Q@that@ value.
\item \Q@method Void update(int x,int y)@
may do two field update at a time.
\item\Q@method This clone()@ may do a shallow clone of the object.
\end{itemize}

We are not sure what is the best set of abstract state operations yet,
but we think this could become a very interesting area of research.
The work by Wang et al.~\cite{wang2016classless} explores a particular
set of such abstract state operations.

\paragraph{Points in \name:}
In \name and with our approach to handle the state, 
\lstinline{pointSum} and \lstinline{pointMul} can be directly composed:

\begin{lstlisting}
  PointAlgebra:Use pointSum,pointMul
\end{lstlisting}  

  As we can see, we can declare the methods independently and compose the result
  as we wish. 

  \paragraph{Improved solution} In this first attempt, we repeated the abstract methods \Q@x@,\Q@y@ and \Q@of@.
  Moreover, in addition to \Q@sum@ and \Q@mul@ we may want many
  operations over points. It is possible to improve reuse
  and not repeat such abstract definitions by abstracting the common
  abstract definitions into a trait \Q@p@: 

\begin{lstlisting}
  p: { method int x() method int y()
    class method This of(int x,int y)
    }
  pointSum:Use p, { method This sum(This that)
      This.of(this.x()+that.x(),this.y()+that.y())
    }
  pointMul:Use p, { method This mul(This that)
      This.of(this.x()*that.x(),this.y()*that.y())
    }
  pointDiv: ...
  PointAlgebra:Use pointSum,pointMul,pointDiv,...
\end{lstlisting}
      
Now the code is fully modularized, and each trait handles exactly one method.

\subsection{State Extensibility}
Programmers may want to extend points with more state. For example 
they may want to add colors to the points. A first attempt at doing
this would be:

\begin{lstlisting}
  colored:{ method Color color() }
  Point:Use pointSum,colored //Failure: resulting class not coherent
\end{lstlisting}

This first attempt does not work: the abstract color method
is not a getter for any of the parameters of 
\Q@ class method This of(int x,int y)@. 
A solution is to provide a richer factory:

\begin{lstlisting}
  CPoint:Use pointSum,colored,{
    class method This of(int x,int y) This.of(x,y,Color.of(/*red*/))
    class method This of(int x, int y,Color color)
    }
\end{lstlisting}

\noindent 
where we assume support for overloading on different number of parameters.
This is a reasonable solution, however the method \Q@CPoint.sum@ resets
the color to red: we call the \Q@of(int,int)@ method, that now
delegates to \Q@of(int,int,Color)@ by passing red as the default field
value.  What should be the behaviour in this case?  If our abstract
state supports withers, instead of writing \Q@This.of(...)@ we can use
\Q@this.withX(newX).withY(newY)@ in order to preserve the color from
\Q@this@.  This solution is still not satisfactory: this design ignores
the color from \Q@that@.

\paragraph{A better design}
If the point designer is designing for reuse and extensibility, then 
a better design would be the following:  
\begin{lstlisting}
  p: { method int x() method int y() //getters
    method This withX(int that) method This withY(int that)//withers
    class method This of(int x,int y)
    method This merge(This that) //new method merge!
    }
  pointSum:Use p, { method This sum(This that)
      this.merge(that).withX(this.x()+that.x()).withY(this.y()+that.y())
    }
  colored:{method Color color()
    method This withColor(Color that)
    method This merge(This that) //how to merge color handled here
      this.withColor(this.color().mix(that.color())
    }
  CPoint:/*as before*/
\end{lstlisting}  
  This design allows merging colors, or any other kind of state we may want to add
  following this pattern.\bruno{worried that withers are not explained
  enough.}

\paragraph{Independent Extensibility}
  Of course, quite frequentely there can be multiple independent
  extensions~\cite{Zenger-Odersky2005} that need to be composed. Lets suppose that 
  we could have a notion of flavoured points as well.   
  In order to compose, let say \Q@colored@ with \Q@flavored@ we would
  need to compose the merge operation inside of both of them.
  The simple model we are presenting could accomodate this with an
  extension allowing code literals inside of a \use\ expression to use some form of super call to compose conflicting implementations. This is similar to the \emph{override} operation present in the original trait model~\cite{ducasse2006traits}.

In the following you can see how to mix colors and flavours. The syntax \Q@_2merge@ and   \Q@_3merge@
call the version of merge as defined in the second/third element of \use.
\begin{lstlisting}
  p: {/*as before*/ }
  pointSum:Use p, {/*as before*/ }
  colored:{/*as before*/}
  flavored:{method Flavor flavor() //very similar to colored
    method This withFlavor(Flavor that)
    method This merge(This that) //how to merge flavors handled here
      this.withFlavor(that.flavor())}//here we just inherit ``that'' flavor
  FCPoint:Use pointSum,colored,flavored{
    class method This of(int x,int y)
      This.of(x,y,Color.of(/*red*/),Flavor.none())
    class method This of(int x, int y,Color color,Flavor flavor)
    //we can resolve the conflict about two implementations for merge
    //by proving our own implementation here
    method This merge(This that) this._2merge(that)._3merge(that)
    }
\end{lstlisting}  

\section{Allowing Reuse against Subtyping}
Before we discussed how traits does not induce a new (externally visible) type.
However, locally in the trait the programmer can use the special type \Q@This@ in order to denote the 
type of \Q@this@.
That is: the program is agnostic to what the \Q@This@ type is going to be, so it can
be later assigned to any (or many) classes. 
The idea is that during flattening, \Q@This@ will be replaced with the actual class name.
In this way, \name allows reuse even when subtyping is
impossible, that is, when a method parameter has type \Q@This@ (also called \emph{binary
  methods}~\cite{}). 
This type of situations is the primary motivator
for previous work aiming at separating inheritance from subtyping.
Leveraging on \Q@This@ type, we can also provide self-instantiation (trait methods can create instances of the class using them) and smootly integrate state and traits: 

  %????Despite the adoption of a nominal approach and unlike other nominally typed languages, the leaking problem does not prevent \name from enjoying such kind of improved reuse.

%To illustrate how \name allows for improved reuse, we consider a
%pattern to combine \emph{multiple trait inheritance} and \emph{state}:
a challenging problem that has limited the flexibility of traits and
reuse in the past.
%First we show how self-instantiation and state are already avaible in the simplest trait model,
%then we show how to radically improve the 

\subsection{Managing State}

This idea of summing pieces of code is very elegant, and has proven
very successfull in module composition
languages~\cite{ancona2002calculus}\bruno{and several trait models?}. 
However our research community is
struggling to make it work with object state (constructor and fields)
while acheving the following goals:

\begin{itemize}
%complicated discussions on this point \item keep sum associative and commutative,
\item managing fields in a way that borrows the elegance of summing methods,
\item actually initialize objects, leaving no null fields,
\item make it easy to add new fields,
\item allowing a class to create instances of itself.
\end{itemize}

In the related work we will show some alternative ways to handle state.
However the purest solution just requires methods:
  The idea is that
  the trait code just uses getter/setters/factories, while leaving
  to classes the role to finally define the fields/constructors.
  That is, the  the class has syntax richer that the trait one,
  allowing declaration for fields and constructors.
  This approach is very powefull~\cite{wang2016classless}
 
\begin{lstlisting}
  pointSum: { method int x()  method int y()//getters
    class method This of(int x,int y)//factory method
    method This sum(This that)
      This.of(this.x()+that.x(),this.y()+that.y())//self instantiation
    }
  pointMul: { method int x() method int y()
    class method This of(int x,int y)
    method This mul(This that)
      This.of(this.x()*that.x(),this.y()*that.y())
    }
\end{lstlisting}

As you see, all the state operations are represented as abstract methods.

\subsection{A First Attempt at Composition}
According to the general ideas expressed before,
\begin{lstlisting}
  Point:Use pointSum,pointMul
\end{lstlisting}  

\noindent would fail since methods \Q@x@,\Q@y@ and \Q@of@ are still abstract.
In this mindset, the user would be required to write something similar to

\begin{lstlisting}
  CPoint:Use pointSum,pointMul, {//not our suggested solution
    int x   int y
    method int x() x       
    method int y() y
    class method This of(int x, int y) new Point(x,y)
    constructor Point(int x, int y){ this.x=x   this.y=y }
    }
\end{lstlisting}

\paragraph*{Advantages:} 
this approach is associative and commutative, even self construction
  can be allowed if the trait requires a static/class method
  returning \Q@This@; the class will then implement this method by forwarding
  a call to the constructor.
  
\paragraph*{Negatives:} writing those obvious ``close the state/fixpoint'' class 
   with the constructors and  fields and getter/setters and factories can be quite tedious.
   %Moreover, there is no way for a trait to specify a default value for a field,
   %the class need to handle all the state, even state that is conceptually
   %"private" of such trait. 
   Former work consider to automatically generate such code~\cite{wang2016classless}.

In our model we go one step further: there is no need to generate code, or to explicitly
write down constructors and fields; there is not even syntax for those
constructs.
The idea is that any class that ``could" be completed in the obvious way
\emph{is a complete ``coherent" class}.
In most other languages, a class is abstract if have abstract methods.
Instead, we call abstract a class whose set of abstract methods is not
coherent, that is, can not be automatically recognized as factory,getters and setters.
  
\paragraph*{Detaild definition of coherent:}
\begin{itemize}
\item a class with no abstract method is coherent, and like Java \Q@Math@.
Will just be usefull for calling class/static methods.
\item a class with a single abstract \Q@class@ method returning \Q@This@
is coherent if all the other abstract methods can be seen as \emph{abstract state
operations} over one of its argument.
For example,
if there is a \Q@class method This of(int x, int y)@ as before,
then
\item a method \Q@int x()@ is intepreted as an abstract state method: a getter for \Q@x@.
\item a method \Q@Void x(int that)@ is a setter for x.
\end{itemize}

While getters and setters are fundamental operations, we can immagine
more operations to be supported; for example
\begin{itemize}
\item \Q@method This withX(int that)@
may be a ``wither", doing a functional field update, that is create a new instance that is like \Q@this@ but where field \Q@x@ has now \Q@that@ value.
\item \Q@method Void update(int x,int y)@
may do two field update at a time.
\item\Q@method This clone()@ may do a shallow clone of the object.
\end{itemize}

We are not sure what is the best set of abstract state operations yet, but we think this could become a very interesting area of research.

\paragraph{The solution in \name:}${}_{}$\\
With our approach to handle the state, the following code can be directly composed:

\begin{lstlisting}
 //same code as before for pointSum and pointMul
  pointSum: { method int x() method int y()
    class method This of(int x,int y)
    method This sum(This that)
      This.of(this.x()+that.x(),this.y()+that.y())
    }
  pointMul: { method int x() method int y()//look we are repeating
    class method This of(int x,int y)//the abstract method declarations.
    method This mul(This that)
      This.of(this.x()*that.x(),this.y()*that.y())
    }
  PointAlgebra:Sum pointSum,pointMul
\end{lstlisting}  

  As you can see, we can declare the methods independently and compose the result
  as we wish. In this first attempt, we repeated the abstract methods \Q@x@,\Q@y@ and \Q@of@.
  In addition of \Q@Sum@ and \Q@Mul@ we may want many operations over points; can we improve our reuse
  and not repeat such abstract definitions? of course!

\begin{lstlisting}
  p: { method int x() method int y()
    class method This of(int x,int y)
    }
  pointSum:Use p, { method This sum(This that)
      This.of(this.x()+that.x(),this.y()+that.y())
    }
  pointMul:Use p, { method This mul(This that)
      This.of(this.x()*that.x(),this.y()*that.y())
    }
  pointDiv: ...
  PointAlgebra:Use pointSum,pointMul,pointDiv,...
\end{lstlisting}
      
Now our code is fully modularized, and each trait handle exactly one method.



\paragraph{Adding state:}${}_{}$\\
What happens if we want to add fields instead of just operations?

\begin{lstlisting}
  colored:{ method Color color() }
  Point:Use pointSum,colored //Failure: resulting class not coherent
\end{lstlisting}

This first attempt does not work: the abstract color method
is not a getter for any of the parameters of 
\Q@ class method This of(int x,int y)@
A solution is to provide a richer factory:

\begin{lstlisting}
  CPoint:Use pointSum,colored,{
    class method This of(int x,int y) This.of(x,y,Color.of(/*red*/))
    class method This of(int x, int y,Color color)
    }
\end{lstlisting}

where we assume to support overloading on different parameter number.
This is a good solution, indeed we think is better that any alternatives in literature,
however the method \Q@CPoint.sum@ resets the color to red: we call the \Q@of(int,int)@ method, that now delegate to \Q@of(int,int,Color)@ by passing red as the default field value.
What should be the behaviour in this case?
If our abstract state supports withers, instead of writing \Q@This.of(...)@ we can use
\Q@this.withX(newX).withY(newY)@ in order to preserve the color from \Q@this@.
This solution is still not sadisfactory: this design ignore the color from \Q@that@.

If the point designer could predict this kind of extension, then we could use the following better design:  
\begin{lstlisting}
  p: { method int x() method int y() //getters
    method This withX(int that) method This withY(int that)//withers
    class method This of(int x,int y)
    method This merge(This that) //new method merge!
    }
  pointSum:Use p, { method This sum(This that)
      this.merge(that).withX(this.x()+that.x()).withY(this.y()+that.y())
    }
  colored:{method Color color()
    method This withColor(Color that)
    method This merge(This that) //how to merge color handled here
      this.withColor(this.color().mix(that.color())
    }
  CPoint:/*as before*/
\end{lstlisting}  
  Now we can merge colors, or any other kind of state we may want to add
  following this pattern.
  
  In order to compose, let say \Q@colored@ with \Q@flavored@ we would
  need to compose the merge operation inside of both of them.
  The simple model we are presenting could accomodate this with an
  extension allowing code literals inside of a \use\ expression to use some form of super call to compose conflicting implementations. This is similar to the \emph{override} operation present in the original trait model~\cite{ducasse2006traits}.

In the following you can see how to mix colors and flavours. The syntax \Q@_2merge@ and   \Q@_3merge@
call the version of merge as defined in the second/third element of \use.
\begin{lstlisting}
  p: {/*as before*/ }
  pointSum:Use p, {/*as before*/ }
  colored:{/*as before*/}
  flavored:{method Flavor flavor() //very similar to colored
    method This withFlavor(Flavor that)
    method This merge(This that) //how to merge flavors handled here
      this.withFlavor(that.flavor())}//here we just inherit ``that'' flavor
  FCPoint:Use pointSum,colored,flavored{
    class method This of(int x,int y)
      This.of(x,y,Color.of(/*red*/),Flavor.none())
    class method This of(int x, int y,Color color,Flavor flavor)
    //we can resolve the conflict about two implementations for merge
    //by proving our own implementation here
    method This merge(This that) this._2merge(that)._3merge(that)
    }
\end{lstlisting}  

#192A

- The statement that "there is no need for classes" is rather
  exaggerated.

We ackowledge in the paper (footnote 1) that *in the context of
Java*, classless merely means that we avoid the "class" keyword:
classes still exist at runtime. So, yes, as the reviewer is right to
say only "Syntactically, classes are removed".

However, the point (which we also discuss in the paper) is that there
are no classes in an hyphotetical true IB language, the current
implementation over Java uses classes because that's how Java works.

- Automatically defined getters and setters are of course a very old
idea, going at least back to Self. They are used in languages such as
Dart and Newspeak. You should discuss this in related work.

We are doing the opposite, we "generate" the idea of the field
starting from getters and setters signatures. But we agree that 
related work should discuss the idea of automatically generated 
setters/getters.

- Compared to a language with mixins and getters/setters, your
approach differs with respect to object construction. This is really
your only possible contribution...
I would argue that your interfaces are rebranded mixins.

It would be more correct to say that our interfaces are rebranded
traits, in the same way traits are rebranded mixins.  Traits are a
restricted model of mixins, they purposly introduce limitations to
provide a more safelly reusable semantics.  Our work generalize traits
but keep the same improvements on the semantics.

Our related work section has extensive discussions on how 
Object interfaces are similar and/or differ from traits 
and mixins, both from a technical and conceptual point-of-view.

BRUNO: Should we still include this?
No, mixins have trouble to merge fields, we avoid that. (needs
improvement, I think).

-What happens if my object stores data that is not in direct
  correspondence with the abstract state?

BRUNO: TODO: Use polar/cartesian example? argue that this 
is indeed one point where Java presents some limitations, but 
the discussion section presents some options in Java, and it 
also discusses how native language support could remove 
such limitations. 

- Your generated code may be type incorrect (due to lack of what you
  call "heir coherence"). Is this reported to the programmer in any
  way?

The generated code (in the sense of the content of the of method and
refined methods) is type correct.

Heir coherence causes type errors, *but these errors are not in the
generated code*. What happens is that the generated code will make
client code incorrect. Such errors are "normally" reported as a error
in user client code. The discussion in Section 3.2, illustrates what 
would happens. For the code:

interface A { int x(); A withX(int x); } 
@Obj interface B extends A {} // no error here!
interface C extends B { A withX(int x); } // **error is here**!

the error would be in interface C, which is client code.

- What happens with debugging?

Please see answer to reviewer #192C.

#192B

- On determining what's a field, and generating of(...) using fields
  as arguments. 

The of(...) method is generated by analizing the names of the methods
in the interface. Users need to follow a naming convention. Table 1
illustrates the naming convention. The first 4 rows show what you need
to write for getting the four possible operations on a field called "x".

- Isn't this somewhat excessive, and potentially, the of() method
  generated not very usable?

Yes, in this case @Obj would generate of(Object first, LinkedList
 next, int size, boolean isEmpty) but this is not the way to write a
 LinkedList in CLJ, you should write

interface LinkedList {//a plain interface with *abtract* methods in Java
 Object first();  LinkedList next();  int size();  boolean isEmpty();
}

In Classless Java interfaces with "real" abstract methods are just
plain old Java interfaces. Later, when you want to create a concrete
implementation you can use @Obj. For example:

@Obj interface EmptyList extends LinkedList{
 default Object first(){/*error*/}
 LinkedList next(){/*error*/}
 int size(){return 0;}
 boolean isEmpty(){return true;}
}
@Obj interface NonEmptyList extends LinkedList{
 int size(){return this.next().size()+1;}
 boolean isEmpty(){return false;}
}

Note how this is much shorter than the equivalent Java version.  

If one wisesh to accept the terrible hack of null, then 
another possible implementation of LinkedList would be:

@Obj interface LinkedList {
 Object first();
 LinkedList next();
 default int size(){
   if (this.next()==null){return 1;}
   return this.next().size()+1;
 }
 //boolean isEmpty();//makes no sense since the empty list is null
}

Here "first" and "next" are fields, and size a concrete method.

- Generating with(...) methods for non-trivial inheritance hierarchies.

Property updaters are generated *only* when users ask for them, that
is, they declare an abstract MyInterfaceName with(AnotherType).
where AnotherType do not need to be in the hierarchy of
MyInterfaceName.  In the example you proposed, *if* the user was to
ask for

Point3D with(Point2D); 
Point3D with(ColoredPoint); 
Point3D with(Point);

Those methods would be all implemented by looking what fields have the
same name and compatible types inside of Point3D and, respectivelly,
Point2D, ColoredPoint, Point.  In general, an updators is just
performing the equivalent of a sequence of with-'s. 

- It seems one would have to know at compile time all the
ways Point2D might be used in the hierarchy,

As a follow up from the previous reply, there's no need to know
compile time all the ways Point2D might be used in the hierarchy,
since users have to explicitly asks for an updater, and the argument 
of with- does not need to be related to the self type.

#192C

- What are the implications for performance? Debugging? IDEs?

TODO: MARCO: Discuss performance

TODO: Say something about debugging.

IDEs: We discuss the IDE support in Section 3. Figure 5 shows an
example of Classless Java running on Eclipse. As the reader can see,
features like auto-completion and the outline view work
out-of-the-box.  Also, Java errors are reported in the IDE (see the
error in line 13, and the underlined code in Point3D).

What *could* be problematic are errors in the *generated code* (i.e. the
implementations of setters, getters, of,...). There would be no way to
present those errors to users. This is a reason why we took care to ensure that
code generation always generates type-correct code; or else an error 
message describing why code cannot be generated is reported to the 
user.

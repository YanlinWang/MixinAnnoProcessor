\section{Bridging between IB and CB in Java}\label{sec:imp}


%\footnote{ Rewriting libraries and
%  application in this language/model would result in more reusable
%  libraries, but it would be a taunting task.}
Creating a new language or language extension would be an
elegant way to illustrate the point of IB. However,
significant amounts of engineering would be needed to build a practical
language, and to achieve a similar level of integration and tool support
as Java. To have an approach that can both illustrate IB
programming and be practical, we have instead implemented Classless Java.
This section presents the Classless Java design.
Disciplined use of Classless Java (that is avoiding class
definitions as done in Section~\ref{}), illustrates what \emph{pure} IB is like.
However in Classless Java CB and IB programming can be mixed together, and all
the practical convenience of using existing Java libraries, the full
Java language, and IDE's are available in Classless Java.
The key to our implementation is the use of compilation agents, which
are supported in Java, and allow us to rewrite the Java AST just
before compilation. We discuss advantages and limitations of our approach.

\subsection{Compilation Agents}
Java supports compilation agents\cite{compilationagents}.
That is, Java libraries can interact with the Java compilation process,
acting as a man in the middle between the
generation of the abstract syntax tree and the Java Bytecode.
\marco{is this correct?}\bruno{my impression is that Lombok happens
  \emph{before} the AST is compiled (not between AST and bytecode generation)}
This process is facilitated by frameworks like Lombok~\cite{lombok}:
a Java library that aims at removing (or
reducing) Java boilerplate code via
annotations. Classless Java was created using Lombok.
Figure~\ref{fig:lombok} illustrates the
flow of \mixin annotation processing in Lombok.\bruno{Haoyuan, please
  explain the diagram.}
\haoyuan{Source code in a Java program is first parsed into its syntactic structure,
which we call abstract syntax tree (AST). The AST is passed to Lombok, and a corresponding
AST defined in Lombok is generated for the annotated node. An annotation like \mixin is declared
inside Lombok, together with an implementation of its (Eclipse or Javac) handler. The handler is
free to modify the information of the annotated node, or even inject new nodes (like methods, inner classes,
etc). Finally, Java compiler works on the modified AST to generate bytecode. During the compilation,
no source code is changed, and no new files are created, bytecode takes the only difference.}

%There are a number of annotations provided by the
%original Lombok, including \Q:@Getter:, \Q:@Setter:,
%\Q:@ToString: for generating getters, setters and \QM{toString}
%methods, respectively.  Furthermore, Lombok provides a number of
%interfaces for users to create custom transformations, as extensions
%to the original framework.
%A transformation is based on a handler, which acts on the AST for the
%annotated node and returns a modified AST for analysis and
%generation afterwards. Such a handler can either be a Javac handler or
%an Eclipse handler.

\begin{figure}[t]
\centering
\includegraphics[width=3in]{pdfs/lombok3.png}
\caption{The flow chart of \mixin annotation processing.
}
\label{fig:lombok}
\end{figure}


\paragraph{Advantages of Lombok}
The Lombok compilation agent has advantages with respect to alternatives like
pre-processors, or other Java annotation processors. In some sense
Lombok can be seen as a poor man's macro system~\cite{} for Java.
\bruno{Marco, do you agree with calling Lombok a poor man's macro system?}
\marco{No, it is as powerful as lisp macros, and have a bigger (may be even  a better) design.}
%this seems like a commercial spot
%\item Lombok is byte-code based instead of source-code based, which makes client
%  code concise and easy to maintain. Such code generation is performed at
%  compile time to modify bytecode.

\paragraph{Direct modification of the AST:}
Lombok alters the generation process of the class files,
by directly modifying the AST. Neither the source code is modified nor
new Java files are generated. Moreover, and probably more importantly,
Lombok supports generation of code \emph{inside} a class/interface,
which conventional Java annotation processors do not support this. For
example, the standard \texttt{javax.annotation} processor, which is part of the
Java platform, only allows generation of \emph{new code}, and the
new code has to be written in \emph{new files}. Modification and/or
reinterpretation of existing code is not supported.

\paragraph{Modularity:}
While general preprocessing acts across module boundaries, compilation
agents act modularly on each class/compilation unit. It makes sense to
apply the transformations to one class/interface at a time, and only to
annotated classes/interfaces. This allows library code to be reused
without the need of being reprocessed and recompiled, making our
approach 100\% compatible with existing Java libraries, which can be
used and extended normally. Of course, Java libraries can also receive
and use instances of object interfaces as normal objects.

\paragraph{Tool support:}
Features written in Lombok integrate and are supported directly in the
language, and are often also supported by (most) tools.  For example in Eclipse, the processing is
performed transparently and the information of the interface from
compilation is captured in the ``Outline'' window.\bruno{Haoyuan: show
and explain figure here.} This includes all
the methods inside the interface as well as the generated ones. \haoyuan{In Figure~\ref{fig:screenshot},
\mixin generates \Q@of@ method in \Q@Point2D@, and \Q@of@, \Q@withX@, \Q@withY@ methods in \Q@Point3D@. These
methods are also visible to users, showing their types and modifiers in Outline window. Moreover, as a useful IDE feature,
the auto-completion also works for these newly generated methods.}

\begin{figure}[h]
\centering
\includegraphics[width=3.3in]{pdfs/screenshot4.png}
\caption{Generated methods shown in the Outline window of Eclipse and auto-completion.}
\label{fig:screenshot}
\end{figure}

\paragraph{Clarity against obfuscation:}
Preprocessors bring great power, which can easily be misused producing
code particularly hard to understand. Thus code quality and maintainability are reduced.
Compilation agents start from Java syntax, but they can reinterpret it.
Preserving the syntax avoid syntactic conflicts, and \marcoT{allows} many
tools to work transparently.

\subsection{AST Reinterpretation in Classless Java}

Ofcourse, careless reinterpretation of the AST could still be
surprising for badly designed rewritings.  Classless Java reinterprets
the syntax with the sole goal of \emph{enhancing and completing code}:
we satisfy the behaviour of abstract methods; we add method
implementations; and we refine return types.  We consider this to be
quite easy to follow and reason about, since it is similar to what
happens in normal inheritance.  Refactoring operations like renaming
and moving should work transparently in conjunction with our
annotaiton, since they rely on the overall type structure of the
class, that we do not arbitrarily modify but just complete.

Thus, in addition to the advantages of Lombok, Classless Java offers
some more advantages with respect to arbitrary (Compilation agent driven) AST rewriting.

%\marco{The section No reuse of the type system
%is controversial.
%We do need to repeat the type checking, plus we aim to make untypable stuff well typed
%(for example anyone using the of method would not be well typed before).}
%\item \textbf{No reuse of the type system.}
%As we mentioned above, badly designed rewritings can arise from the great power of Lombok. A simple piece of source code
%\begin{lstlisting}
%interface M { int m(); }
%\end{lstlisting}
%can be reinterpreted as
%\begin{lstlisting}
%interface M { void m(String s); }
%\end{lstlisting}
%in which case the type of method \Q@m@ is changed. Our \mixin annotation does not introduce this kind of rewritings,
%and hence the type system is reused. Moreover, Lombok can also modify unbounded types, which is easy to understand,
%for instance, the following code
%\begin{lstlisting}
%interface M { T m(); } // T is unbounded
%\end{lstlisting}
%is transformed into
%\begin{lstlisting}
%interface M { int m(); } // No error message
%\end{lstlisting}
%in which case the user will see the unbounded type in source code, but without error message from the compilation, since
%Lombok has modified the return type of \Q@m@. However, our \mixin annotation can still keep such errors and warnings.


%\item \textbf{Lack of reuse.}  %not sure here... I think most preprocessors support decent reuse, even the C one
%Reusability is yet another concern in using preprocessors.
% In Lombok, implementations of features are
%encapsulated in various annotation handlers,
% in which case some behaviours are allowed to reuse the code by invoking methods
%in other handlers, where tedious replicated code is avoided.



\paragraph{Syntax and Type Errors:}
Some preprocessors (like the C one) can produce syntactically invalid code.
Lombok ensures only syntactically valid code is produced. %; however, type errors can appear.
Classless Java additionally guarantees that no type errors are introduced
in generated code and client code. We discuss these two guarantees in
more detail next:

\begin{itemize}

\item{\bf Self coherence}: the generated code itself is well-typed. That is,
  type errors are not present in code the user has not written.
In our case it means that either \mixin{} produces (in a controlled way) an
understandable error, or the interface can be successfully annotated and the generated code is well-typed.

\item{\bf Client coherence}: all the client code (for example method calls)
  that is well-typed before code generation is also well-typed after the generation.
The annotation just adds more behaviour without removing any functionality.

\end{itemize}

\paragraph{Heir coherence:} Another form of guarantee that could be
useful in AST rewriting would be heir coherence. That is, interfaces
(and in general classes) inheriting the instrumented code are
well-typed if they were well-typed without the instrumentation.
Classless Java \emph{does not} guarantee heir coherence.  The reason
is that this would forbid adding any (default or abstract) method to
the annotated interfaces, including type refinement. Indeed consider
the following:

\begin{lstlisting}
interface A { int x(); A withX(int x); }
@Obj interface B extends A {}
interface C extends B { A withX(int x); }
\end{lstlisting}

\noindent This code is correct before the translation, but \mixin would  generate in \Q@B@  a method ``\Q@B withX(int x);@''.
This would break \Q@C@.
Similarly, an expression of the form ``\Q@new B(){.. A withX(int x){..}}@''
would be correct before translation, but would be ill-typed after the translation.

Our automatic type refinement is a useful and convenient feature, but
not transparent to the heirs of the annotated interface.  They need to
be aware of the annotation semantics and provide the right type while
refining methods. To support heir coherence, Classless Java would need
to give up automatic type refinement, which is an essential part of IB programming.
However, the reader should note that Java libraries almost always break heir
coherence during evolution and still claim backward compatibility (false in
theory but statistically true in practice). In practice to break heir
coherence it is just enough to add any method to any
non final class of a Java library.  We think refining return
types breaks heir coherence ``less" than normal library evolution.

In Section~\ref{} \marcoT{we provide a formal definition for our
safety claims.}

\subsection{Limitations}\marco{ to reorganize with updated limitations}
\haoyuan{Should we only present the separate compilation and simple generics features in this (limitation) section?}
Our prototype implementation using Lombok has certain limitations:
\begin{itemize}
\item \haoyuan{The annotation \mixin does not support separate compilation yet. Using \mixin, all
  related interfaces have to appear in a single Java file. Therefore, changes to
  a single interface would require re-compiling the whole file. Nevertheless, to support separate compilation we
  studied an existing yet experimental feature \lstinline{@Delegate}, reused the name and modified its behavior.
  Now files in the same package can be compiled and \lstinline{@Delegate} has the same behavior as \mixin. A limitation is
  that users need to put references to the super types of the annotated type together with the annotation, for instance,
  \lstinline{@Delegate(types = Point2D.class)}. Another limitation is the methods generated by \lstinline{@Delegate} will
  not be visible in the Outline window, but they can still be auto-completed in Eclipse.}
\item At this stage our implementation only realizes the Eclipse handler and our
  experiments are all conducted in Eclipse. The implementation for
  \texttt{javac} is missing.
\item \haoyuan{The current implementation only supports simple generics, which means type parameters can be used, however, the generic
method typing is neither formalized in this paper nor implemented, but delegated to the Java compiler.}
\end{itemize}


%\paragraph{Lombok does language tuning}
%We consider Lombok to be the most developed example of language
%tuning.  While the authors of Lombok do not introduce a specific term
%for what they are doing, their slogan \emph{``Spice up your java''}
%seems to be in line with the philosophy of language tuning. Some
%other examples of language tuning in Lombok include the \Q@val@ type,
%similar to \Q@auto@ in C\# or C++04.  Another library doing language
%tuning is CoFoJa~\cite{cofoja}, where annotations are used to insert
%pre-post conditions in generated bytecode.


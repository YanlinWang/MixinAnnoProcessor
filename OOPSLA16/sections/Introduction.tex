\section{Introduction}\label{sec:intro}

\marcoT{Object oriented languages always strive to offer great code reuse.}
They aim to couple flexibility and rigour, expressive power and
modular reasoning.  Two main ideas have emerged to this end: prototype
based (PB)~\cite{} and class based (CB) languages~\cite{}.  In prototype based
languages objects inherit from other objects, and thus objects own
both behaviour and state (and objects is all you have).
In class based languages an object is instance of a specific class,
and classes inherit from other classes.  Here objects own the state,
while classes contain behaviour and the structure of the state.

We present here a third alternative: the concept of \textbf{Interface
  based} (IB) object oriented languages, where objects implement
interfaces directly. In IB interfaces own the implementation for the behaviour, which
is structurally defined in their interface.

\marcoT{
A key challenge lies in how to model state, which is fundamental to
have stateful objects. 
Programmers do not define objects directly, but
delegate the task to \emph{object interfaces}, whose role is similar
to non abstract classes in CB languages.
All abstract operations in an object interface will be interpreted as \emph{abstract state operations}. The
abstract state operations include various common utility methods (such
as getters and setters, or clone-like methods). In the presence of
subtyping, such operations often require special care, as their types
need to be refined. Object interfaces provide support for
type-refinement and can automatically produce code that deals with
type-refinement adequately, while CB (as in Java, Scala and C\#) require 
verbose explicit type-refinement.
We believe that such verbosity hindered and slowed down
the discovery of useful programming pattens involving type-refinement\cite{trivialsolutiontotheEP}.
}

Finally, object interfaces also provide static factory methods instantiating objects.

\marcoT{%
Objects are the only responsible to define the
ultimate behaviour of a method and, for example, if such method is
just a setter. Anything related to state is completely contained in
the instances and do not leak in the inheritance logic.
In CB, the structure of the state is fixed and can be only
grown by inheritance; on the opposite, in IB the state is never fixed,
and methods that ``looks like'' abstract setters and getters
can always receive an explicit implementation down in the inheritance chain,
improving \textbf{modularity and flexibility}.

That is, the concept of abstract state is more fluid.
In this paper we show how to support type-safe
\textbf{field removal},
\textbf{field type refinement} allowing a kind of covariant setters refinement,
and \textbf{multiple inheritance}.}

Indeed the literature
provides good examples on how easy and modular it is to combine
multiple sources of pure behaviour, using mechanisms such as
traits~\cite{scharli03traits}. 
In Java multiple \emph{interface} inheritance has been
supported since inception, and in Java8 default methods~\cite{} bring some of
the advantages of traits into Java. In contrast, the literature~\cite{} is
also rich on how hard it is to modularly combine multiple sources of
behaviour \textbf{and} state with multiple \emph{implementation}
inheritance of classes. 
%Traits or Java8 interfaces still assume a CB model: 
%But traits still require classes, which
%are responsible for object construction and adding state.

%To retain the easiness and modularity of combining multiple sources of
%pure behaviour, in IB state is just a special kind of behaviour
%implementation.
%\marco{NO NO!
%the advantage is not just multiple composition 
%(by the way, that is the term you are searching for, not multiple inheritance)
%By not having state reified in the ideal/platonic level, it is not fixed
%what is state and what is not, thus you can (model an encoding of) REMOVE fields and you can refine
%fields.}
% Objects are the only responsibles to define the
%ultimate behaviour of a method and, for example, if such method is
%just a setter. Anything related to state is completely contained in
%the instances and do not leak in the interfaces.





\bruno{To be mentioned: 3 features of IB: Interface-based programming with multiple
  inheritance; automatic type-refinements; a new approach that allows 
\emph{type-safe} covariant refinement of state.
}





\bruno{Not sure if
  this is totally clear. Implicit here is the fact that objects are
  never defined explicitly, I think. And the behaviour is introduced 
implicitly.}
\marco{we need to discuss, not clear what you mean}
%\footnote{ In the same sense,
%  you can encode prototype based programming over class based with the
%  strategy pattern, and class based programming with prototypes by
%  creating ``class'' objects.}

IB could be explained by defining a novel language, with new syntax
and semantics. However, this would have a steep learning curve.  We
take a different approach instead. For the sake of providing a more
accessible explanation, we will embed our ideas directly into Java. 
Our IB embedding relies on the
new features of Java 8 for interfaces: interface \emph{static methods}; and
\emph{default methods}, which allow interfaces to have method
implementations. 

%Still, the design is quite conservative and appears to be quite limited
% in its current form to model advanced forms of multiple inheritance.
%Indeed, our own personal experience of combining default methods 
%and multiple interface inheritance in Java to achieve multiple implementation 
%inheritance is that many workarounds and boilerplate code are needed. 
%In particular, we encountered difficulties because:

%\begin{itemize}
%
%\item {\em Interfaces have no constructors.} As a result, classes are 
%still required to create objects, leading to substantial boilerplate 
%code for initialization.
%
%\item {\em Interfaces do not have state.} This creates a tension between 
% using multiple inheritance and having state. Using setter and
%  getter methods is a way out of this tension, but this workaround
%  requires tedious boilerplate classes that later implement those
%  methods.
%
%\item {\em Useful, general purpose methods require special care in
%  the presence of subtyping.} Methods such as
%  \emph{fluent} setters~\cite{fowler2005fluentinterface}, not only require access to the
%  internal state of an object, but they also require their return types to be
%  refined in subtypes.
%
%\end{itemize}

%\noindent Clearly, a way around those difficulties would be to change
%Java and just remove these limitations. Scala's own notion of
%traits~\cite{scala-overview}, for example, allows state in traits. Of
%course adding state (and other features) to interfaces would
%complicate the language and require changes to the compiler, and this
%would go beyond the goals of Java 8 development team.

%This paper takes a different approach. Rather than trying to get
%around the difficulties by changing the language in fundamental ways,
%we show that, with a simple language feature, default methods and
%interface inheritance are in fact very expressive.

In the context of Java, what we propose is essentially a programming
style, where we never use classes\footnote{More precisely, we never
  use the \Q@class@ keyword.}.  We call this restricted version of
Java \emph{Classless Java}.  



  %With object interfaces, many Java programs can be built
%without using a single class!

Using Java annotation processors, we produce an implementation of
Classless Java, which allow us to stick to pure Java8. By annotating
with \Q|@Obj| the interfaces that represent object interfaces, we can
generate boring and repetitive code for interface instantiation and
type refinement. Such code should not be needed in the first place in
a real IB language, and the annotation processor allows us to
transparently hide it from Java programmers. 
The implementation works by performing \emph{on-the-fly}\marco{False, we
generate the instrumented bytecode. on the fly ast rewriting is a term that means 
that you modify the bytecode while you load it} AST
rewriting, allowing existing Java tools (such as IDEs) to work
out-of-the-box with our implementation. Moreover, the 
implementation blends Java's conventional CB style and IB smoothly. 
As a result, we experiment object interfaces with several interesting Java programs,
and conduct various case studies. 
Finally, we also formally define the behaviour of our \Q|Obj| annotation. 



%Since Java was not designed to be used in this way, our style can be verbose, especially about object instantiation.


%
%Object interfaces do not require changes to the Java runtime or compiler, 
%and they also do not introduce any new syntax. All three features of object interfaces are
%achieved by reinterpreting existing Java syntax, and are translated
%into regular Java code without loss of type-safety. Since no new
%syntax is introduced, it would be incorrect to call object interfaces
%a language extension or syntactic sugar. So we use the term
%\emph{language tuning} instead. Language tuning sits in between a
%lightweight language extension and a glorified library. Language
%tuning can offer many features usually implemented by a real language
%extension, but because it does not modify the language syntax
%pre-existing tools can work transparently on the tuned language.  To
%exploit the full benefits of language tuning,



%To formalize object interfaces, we propose Classless Java (CJ): a
%FeatherweightJava-style~\cite{Igarashi01FJ} calculus, which captures the essence
%of interfaces with default methods. The semantics of object interfaces
%is given as a syntax-directed translation from CJ to itself. In the
%resulting CJ code, all object interfaces are translated into regular CJ
%(and Java) interfaces with default methods. The translation is proved
%to be type-safe, ensuring that the translation does not
%introduce type-errors in client code. 
%CJ's usefulness goes beyond serving as a
%calculus to formalize object interfaces. During the development
%process of CJ, we encountered a bug in the implementation of default
%methods for the Eclipse Compiler for Java (ECJ). For the program revealing the 
%bug, ECJ behaves differently from both our formalization and Oracle's 
%Java compiler.

To evaluate the usefulness of object interfaces, we illustrate
\numOfCaseStudies \bruno{needs updates}\yanlin{updated} 
applications. The first application is a simple 
solution to the Expression Problem~\cite{wadler98expression}, supporting independent 
extensibility~\cite{zenger05independentlyextensible}, and without boilerplate code. The second
application shows how embedded DSLs using fluent interfaces~\cite{fowler2005fluentinterface} 
can be easily defined using object interfaces. The third
application is a case study for a simple Maze game implemented with 
multiple inheritance. For this application we show that there is a
significant reduction in the numbers of lines of code when compared 
to an existing implementation~\cite{bono14} using plain Java 8. The last
application is a larger case study of refactoring of a simple one-pass compiler, showing that our
approach can scale to real code base. Noteworthy, all applications are implemented 
without defining a single class!

We can extend our approach to support encapsulation and privateness;
various possibilities are discussed in the last part of the paper.


In summary, the contributions of this paper are:
\begin{itemize}

\item {\bf IB and Object Interfaces:} a novel take on object orientation, allowing
  powerful multiple-inheritance programming idioms to be expressed
  conveniently in Java. We provide examples, informal and formal description.

\item{\bf Type preservation guarantees:}\bruno{needs rephrasing}
We discuss our formalization of a subset of Java8 type system and how we use this
to characterize safety properties about our annotations.
%\item {\bf Classless Java (CJ):} A simple formal calculus that models 
%the essential features of Java 8 interfaces with default methods, and 
%can be used to formally define the translation of object interfaces. 
%We prove several properties of the translation\footnote{Proofs and prototype implementation are available in
%  the supplementary materials.}.

\item {\bf Implementation and Case Studies:} We have a prototype
  implementation of object interfaces, using Java
  annotations and AST rewriting. Moreover, the usefulness of object interfaces is
  illustrated through various examples and case studies.

%\item{\bf Language Tuning:} We identify the concept of language tuning 
%and describe object interfaces as an example. We also discuss 
%how other existing approaches, such as the annotations in project 
%Lombok~\cite{lombok},  can be viewed as language tuning.

\end{itemize}

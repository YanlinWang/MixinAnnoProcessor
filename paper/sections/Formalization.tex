\section{Formal Semantics}\label{sec:formal}

This section presents a formalization of ClassLess Java: a minimal
FeatherweightJava-like calculus which models the essence of Java 
interfaces with default methods. This calculus also supports a minimal
extension to Java to account for the \mixin annotation for object
interfaces. The syntax, typing rules and method lookup mechanisms 
of CJ are modelled. Finally, using our formalization, we discuss
examples of real Java programs that seem to be incoherent\bruno{revise
later}.

\begin{figure}[t]
\begin{grammar}
\production{
\e
}{
  \x\mid\MCall\e\m\es\mid\MCall{\C}\m\es\mid\MCall{\C\QM{.super}}\m\es\mid\x\QM=\e\QM;\e'\mid\obj
  }{expressions}\\
\production{
\obj
}{
\QM{new}\ \C\oR\cR\oC\fields\
\mh_1\oC\QM{return}\ \e_1\QM{;}\!\cC
\ldots
\mh_n\oC\QM{return}\ \e_n\QM{;}\!\cC
\cC
  }{object creation}\\
\production{\field}{\T\ \f \QM= \x\QM;}{field declaration}\\
\production{
\II
}{
 \ann\ \QM{interface}\ \C_0\ \QM{extends}\ \Cs\ \oC \methods\ \cC
  }{interface declaration}\\
\production{
\method
}{
 \QM{static}\ \mh\ \oC\QM{return}\ \e\QM{;}\!\cC
\mid
\QM{default}\ \mh\ \oC\QM{return}\ \e\QM{;}\cC
\mid
\mh\QM{;}
  }{method declaration}\\
\production{
\mh
}{
 \T_0\ \m\ \oR\T_1\ \x_1\ldots\T_n\ \x_n\cR
  }{method header}\\
\production{
\ann
}{
  \mixinAnn|\emptyset
  }{annotations}\\
\production{\Gamma}{
\x_1{:}\C_1\ldots\x_n{:}\C_n
}{environment}
\end{grammar}
\caption{Grammar of ClassLess Java}
\label{Grammar}
\end{figure}

\subsection{Syntax and Typing}\marco{Future work: updating multiple fields in one method call,
  \texttt{with(T v)}}

\paragraph{Syntax}
Figure~\ref{Grammar} shows the syntax of ClassLess Java.  \footnote{To
  be compatible with java, the concrete syntax for an interface
  declaration with empty supertype list $\C_1\ldots\C_n$ would also
  omit the \Q@extends@ keyword.}  The syntax formalizes a minimal
version of Java 8, focusing on interfaces, default methods and object
creation literals.  There is no syntax for classes.  Expressions
consist of conventional constructs such as variables ($\x$), method
calls ($\e\QM.\m\QM(\es)$) and static method calls
($\C\QM.\m\QM(\es)$). For simplicity the degenerate case of calling a
static method over the $\this$ receiver is not considered.  A more
interesting type of expressions are super calls
($\C\QM{.super.}\m\QM(\es)$), whose semantic is to call the (non
static) method $\m$ over the $\this$ receiver, but statically
dispatching to the version of the method defined in the interface
$\C$. A simple form of field updates ($\x\QM=\e\QM;\e'$) is also
modelled. In the syntax of field updates $\x$ is expected to be a
field name. After updating the field $\x$ using the value of $\e$, the
expression $\e'$ is executed. To blend the statement based nature of
Java and the expression based nature of our language, we consider a
method body of the form \Q@return@ $\x\QM=\e\QM;\e'$ to represent
$\x\QM=\e\QM;\QM{return}\ \e'$ in Java.  Finally, there is an object
initialization expression from an interface $\C$, where (for
simplicity) all the fields are initialized with a variable present in
scope. Note how our language is a subset of Java 8.  The single
non-Java 8 piece of syntax is the \mixin annotation, which is the only
one interesting piece of syntax in this article.  Following standard
practise, we consider a global Interface Table (\metaVar{IT}) mapping
from interface names $\C$ to interface declarations \metaVar{I}.

The environment $\Gamma$ is a mapping from variables to types.  As
usual, we allow a functional notation for $\Gamma$ to do variable
lookup.  Moreover, to help us defining auxiliary functions, a functional
notation is also allowed for a set of methods $\methods$, using the
method name $\m$ as a key.  That is, we define $\methods(\m)=\method$
iff there is a unique $\method\in\methods$ whose name is $\m$.  For
convenience, we define $\methods(\m)=\none$ otherwise; moreover
$\m\in\dom(\methods)\ \miff\ \methods(\m)=\method$.


\paragraph{Typing} 
Typing statement $\Gamma \vdash \e\in\C$ reads ``in the environment
$\Gamma$, expression $\e$ has type $\C$.''. 
Before discussing the typing rules we discuss some of the used notation.
As a shortcut, we write
$\Gamma \vdash \e\in\C<:\C'$ instead of $\Gamma \vdash \e\in\C$ and
$\C<:\C'$.  From the interface table, we can read off the subtype
relation between interfaces. The subtype relation is given by the
\textbf{extends} clauses in the interfaces. We omit the definition of
the usual\bruno{where can it be found? add reference here?}, traditional subtyping relation between interfaces.%
\footnote{ Notice how there are no classes, thus there is no
  subclassing.  We believe that this approach may scratch an old
  itching point in the long struggle of subtyping versus subclassing:
  According to some authors, from a software engineering perspective,
  interfaces are just a kind of classes. Others consider more
  opportune to consider interfaces are pure types. In this vision our
  language would have no subclassing. We do not know how to conciliate
  those two viewpoints and ClassLess Java design. We do not have
  Classes purely in the Java sense.}\bruno{is a footnote here the
  appropriate place to have this discussion?}
The auxiliary notation $\Gamma^\mh$ trivially
extracts the environment from a method header, by collecting the all types
and names of the method parameters.  The
notation $\m^\mh$ and $\C^\mh$ denotes, respectivelly, extracting the
method name and the return type from a method header. $\mBody(\m,\C)$,
defined in Section~\ref{},
returns the full method declaration as seen by $\C$, that is the
method $\m$ can be declared in $\C$ or inherited from another
interface. 
$\textsf{mtype}(\m,\C)$ and $\textsf{mtypeS}(\m,\C)$ return the type
signature from a method (using $\mBody(\m,\C)$ internally).
$\textsf{mtype}(\m,\C)$ is defined only for non static methods, while
$\textsf{mtypeS}(\m,\C)$ only on static ones. We use $\dom(\C)$ to
denote the set of methods that are defined for type $\C$, that is:
$\m\in\dom(\C)\ \miff \ \mBody(\m,\C)=\method$.

\begin{figure}[t]
$
\begin{array}{l}

%% T-Invk
\inferrule[(T-Invk)]{
 \Gamma \vdash \e \in \C \\\\
\forall i\in 1..n\ \ \Gamma \vdash \e_i \in \_<:\C_i \\\\
  \textsf{mtype}(\m,\C) \!=\! \overline{\C} \!\!\to\! \C'
%\textsf{mmodifier}(\m,\C) \neq \textbf{static}
 }{
 \Gamma \vdash \e\QM.\m\QM(\overline{\e}\QM) \in \C' }
\quad\quad

%%T-StaticInvk
\inferrule[(T-StaticInvk)]{
\forall i\in 1..n\  \ \Gamma \vdash \e_i\in \_<:\C_i \\\\
\textsf{mtypeS}(\m,\C) \!=\! \overline{\C} \!\to\! \C'
%\textsf{mmodifier}(\m,\C) = \textbf{static}
}{
\Gamma \vdash \C\QM.\m\QM(\overline{\e}\QM) \in \C'}
\quad\quad

%%T-SuperInvk
\inferrule[(T-SuperInvk)]{
\Gamma(\this) <: \C \\\\
\forall i\in 1..n\ \ \Gamma \vdash \e_i\in \_<:\C_i \\\\
  \textsf{mtype}(\m,\C) \!=\! \overline{\C} \!\!\to\! \C'
%\textsf{mmodifier}(\m,\C_0) \neq \textbf{static} \\\\
}{\Gamma \vdash \C\QM.\QM{super}\QM.\m\QM(\overline{\e}\QM) \in \C'}


%%T-Var
\\[5ex]
\inferrule[(T-Var)]{
\Gamma(\x)=\C
}{
\Gamma \vdash \x \in\C}
\quad\quad

%%T-Obj
\inferrule[(T-Obj)]{
\forall i\in 1..k\ \ \Gamma(\x_i)\subtype\T_i\\\\
\forall i\in 1..n\ \ 
%\Gamma_i
\Gamma,\f_1{:}\T_1,\ldots,\f_k{:}\T_k,\,\QM{this}{:}\C,\Gamma^{\mh_i}
\vdash\e_i\in \_\subtype\C^{\mh_i}\\\\
\sigvalid(\mh_1\ldots\mh_n,I)\quad\quad\quad\quad
%\forall i\in 1..n\ \mh_i\subtype\mBody(\m^{\mh_i},\C)\\\\
\alldefined(\mh_1\ldots\mh_n,I)
%\forall\m\mbox{ such that }
%\mBody(\m,\C)=\mh\QM; \exists i\in 1..n\ \m^{\mh_i}=\m
%\forall i\in 1\ldots n\ \Gamma_i=\Gamma,\f_1{:}\T_1,\ldots,\f_k{:}\T_k,\,\QM{this}{:}\C,\Gamma^{\mh_i}
}{
\Gamma \vdash\QM{new}\ \C\oR\cR\oC\T_1\ \f_1\QM=\x_1\QM;\ldots\T_k\ \f_k\QM=\x_k\QM;\
\mh_1\oC\QM{return}\ \e_1\QM{;}\!\cC
\ldots
\mh_n\oC\QM{return}\ \e_n\QM{;}\!\cC
\cC
\in\C
}
\\[5ex]



%%T-update
\quad
\inferrule[(T-update)]{
\Gamma \vdash \e\in\_<:\Gamma(\x)\\\\
\Gamma \vdash \e'\in\C
}{
\Gamma \vdash \x\QM=\e\QM;\e'\in\C }
\quad\quad\quad

%%T-Intf
 \inferrule[(T-Intf)]{
IT(\C) = \ann\ \QM{interface}\ \C\ \QM{extends}\ \overline{I} \
\oC\methods\ \cC\\\\
 \forall \QM{default}\ \mh\oC\QM{return}\ \e\QM;\cC \in \methods,
\ \ \Gamma^{\mh},\,\QM{this}{:}\C\vdash\e\in \_\subtype\C^{\mh} \\\\
 \forall \QM{static}\ \mh\oC\QM{return}\ \e\QM;\cC \in \methods,
\ \ \Gamma^{\mh}\vdash\e\in \_\subtype\C^{\mh} \\\\
\dom(\C)=\dom(\C_1)\cup\ldots\cup\dom(\C_n)\cup\dom(\methods)
 }{
\C \text{ OK}
}
\end{array}$
\caption{CJ Typing}
\label{ET}
\end{figure}

In Figure~\ref{ET} we show the typing rules.  We discuss first the
most interesting rules, that is \rn{t-Obj} and \rn{t-Intf}. Rule
\rn{t-Obj} is the most complex typing rule. Firstly, we need to
ensure that all field initializations are type correct, by looking up the type of
each variable assigned to a field in the typing environment and verifying that such type is a
subtype of the field type. Secondly, we check that all method bodies are
well-typed. To do this the enviroment used to check the method body
needs to be extended appropriately: we add all fields and their types;
add $\this:I$; and add the arguments (and types) of the respective
method. Finally, we need to check that all method headers are valid
with respect to the superinterfaces of $I$; and we also need to check
that all abstract and conflicted methods (that is methods, that need
to be explicitly overriden) in the superinterfaces have been
implemented. The definitions $\sigvalid$ and $\alldefined$ take care
of this: \\
\marco{there can be no conflicted method in I, the user need to manually solve the conflict for mixin to work}

$
\begin{array}{lll}
\sigvalid(\mh_1\ldots\mh_n,I) & = &
\forall i\in 1..n\ \ \mh_i\subtype\mBody(\m^{\mh_i},\C)\\

\alldefined(\mh_1\ldots\mh_n,I) & = &
\forall\m\mbox{ such that } \mBody(\m,\C)=\mh\QM; \exists i\in 1..n\ \m^{\mh_i}=\m
\end{array}
$\bruno{Marco, you probably want to double-check the explanation. Any
  more explanation needed?}
\bruno{Also, according to the text above, mbody returns the full
  method body, so in sigvalid, shouldn't we use mtype instead? The
  same for alldefined, should it be mtype? Still not very confident
  about alldefined. }

The rule \rn{(t-intf)} checks that an interface $\C$ is correctly
typed.  First we check that the body of all the default and static
methods are well typed.  Then we check that $\dom(\C)$ is the same of
$\dom(\C_1)\cup\ldots\cup\dom(\C_n)\cup\dom(\methods)$.  This is not a
trivial check, since $\dom(\C)$ is defined using $\mBody$, that is
undefined in many cases: notably if a method $\method\in\methods$ is
not compatible with some method in $\dom(\C_1)\ldots\dom(\C_n)$ or if
any method in both $\dom(\C_i)$ and $\dom(\C_j)$ ($i,j\in 1..n$) is
conflicting.
\marco{if we have space we can discuss the other rules too, but is not mandatory}

\subsection{Auxiliary Definitions}

\begin{comment}
\subsubsection{Auxiliary function: \textsf{mtype}}
- \textsf{mtype(m, C)} : the signature of method m in C.

\[ \inferrule{
  IT(T) = \text{\emph{ann} interface } C \{ \overline{M} \} \\
  E \spc m(\overline{D} \spc \overline{x}) \{ \text{return } e; \} \in M}
{ \textsf{mtype(m,T)} = \overline{D} \to E } \]

\[ \inferrule{
  IT(T) = \text{\emph{ann} interface } C \{ \overline{M} \} \\
  m \notin M}
{ \textsf{mtype(m,T)} = \emptyset } \]

\[ \inferrule{
  IT(T) = \text{\emph{ann} interface } C \text{ extends } C_1,...,C_k \{ \overline{M} \} \\
  E \spc m(\overline{D} \spc \overline{x}) \{ \text{return } e; \} \in M}
{ \textsf{mtype(m,T)} = \overline{D} \to E } \]

\[ \inferrule{
  IT(T) = \text{\emph{ann} interface } C_0 \text{ extends } \overline{C} \{
  \overline{M} \} \\
  m \notin M}
{ \textsf{mtype(m,T)} = \bigcup \textsf{mtype}(m,\overline{D}) } \]
\end{comment}


Defining \mBody{} is not trivial, and requires quite a lot of attention to the specific model of Java Interfaces, and on how it differs w.r.t. Java Class model.
$\mBody(\m,\C)$ denotes the actual body of method $\m$ that interface $\C$ owns. It can either be defined originally in $\C$ or in its supertypes, and then passed to $\C$ via inheritance.

The body of a method $\m$ contains all the relevant information with respect to that method, like the type of $\m$ as well as the modifier.
We use internally a special modifier $\conflicted$ to denote the case of two methods with conflicting implementation.\\*

$\mBody(\m,\C_0) = \override(\methods(\m),
\shadow(\m,\Aux{tops}(\Cs)))
$\\*
Where
$\metaVar{IT}(C_0) =
\ \ann\ \QM{interface}\ \C_0\ \QM{extends}\ \Cs\ \oC\methods\cC$

As you can see, we are delegating the work to three others auxiliary functions:\\*
 $\tops(\Cs), \shadow(\m,\Cs)$ and $\override(\method,\method')$
${}_{}$\\*
\marco{we need to discuss the names tops, shadow and override}

\tops{} recover from the interface table only the ``needed'' methods, that is,
the non static ones that are not transitively reachable by following another, less specific, superinterface chain. Formally:\\*
$\method\in\tops(\m,\Cs) \mbox{ iff }\C\in\Cs\ ,\method=\mBody(\m,\C), \method\mbox{ not a static method}$\\*
${}_{}$\tab and $\nexists \C'\in\Cs\setminus\C$ such that $\C' \subtype \C$.

\shadow{} choose the most specific version of a method, that is the unique version available, or a conflicted version from a set of possibilities.
We do not model overloading, so it is an error if multiple versions are available with different parameter types. Formally:\\*
\!\!\!\!$\begin{array}{l}
%\shadow(\m,\C_1\ldots\C_n)=\shadow(\methods)
%\whereNote
% \mwhere\ \mBody(\m,\C_i)\in\methods
%\ \mif\ \mBody(\m,\C_i)\in\{\mh\QM;,\QM{default}\ \mh\mbox{\Q@\{return \_;\}@}\}
%\\ &\mor\ \mBody(\m,\C)=\mh\QM;
%\\

\shadow()=\none\\
\shadow(\method)=\method\\
\shadow(\overline{\mh\QM;})=\Aux{mostSpecific}(\overline{\mh\QM;})\\
\shadow(\methods)=\conflicted\mh\QM;
\whereNote
\mwhere\
\methods\mbox{ not of the form }\overline{\mh\QM;}\mbox{ and }
\Aux{mostSpecific}(\methods)\in\{\mh\QM;,\QM{default}\ \mh\mbox{\Q@\{return \_;\}@}\}\\
\Aux{mostSpecific}(\methods)=\method
\whereNote
\mwhere\ \method \in \methods\ \mand\ \forall \method' \in \methods :  \method \subtype
                                       \method', \\
\T\ \m\oR\T_1\x_1\ldots \T_n\x_n\cR \subtype \T' \m\oR\T_1\x_1'\ldots\T_n\x_n'\cR
\whereNote
 \mwhere\ \T\subtype \T'\\

\method \subtype
\QM{default}\ \mh\,\mbox{\Q@\{return \_;\}@}=
\method\subtype\mh\QM;
\\
\QM{default}\ \mh\,\mbox{\Q@\{return \_;\}@}\subtype\method=
\mh\QM;\subtype\method
\end{array}$
${}_{}$\\*
Where $\Aux{mostSpecific}$ return the most specific method using return type specialization as introduced in Java\marco{insert the version number}
We just check the subtype between method headers, so we discard information abut method implementation.\\*
${}_{}$\\*
The override function models how the implementation in an interface can override implementation in the superinterface; even in case of a conflict.
Note how we use the special value $\none$, and how (forth case) overriding can solve a conflict.
\\*
\!\!\!\!$\begin{array}{ll}
\override(\none,\none)=\none\\
\override(\method,\none)=\method\\

\override(\none,\method)=\method
\whereNote
\mwhere\ \method\mbox{ not of the form } \conflicted\ \mh\QM;\\
\override(\method,\method')
=
\method
\whereNote
\mwhere\ \method'\in\{\mh\QM;,\QM{default}\ \mh\,\mbox{\Q@\{return \_;\}@}, \conflicted\ \mh\QM; \},
\method\subtype\method'
\\
%\override(\method,\mh')
%=\method
%\whereNote
%\mif\ \method\in\{\mh\QM;,\QM{default}\ \mh\mbox{\Q@\{return \_;\}@} \}, \mh\subtype\mh'
%\override(\_,\_)=\error & Otherwise
%\textsf{shadow}(body_1, body_2)=\emptyset & \textsf{if }body_1.\textsf{modifier}=body_2.\textsf{modifier}=\textbf{static}\\
%\textsf{shadow}(body_1, body_2)=body_1 & \textsf{if }body_2=\emptyset\textsf{ or }body_2.\textsf{modifier}=\textbf{static}\\
%\textsf{shadow}(body_1, body_2)=body_2 \hspace{.1in}  & \textsf{if }body_1=\emptyset\textsf{ or }body_1.\textsf{modifier}=\textbf{static}
\end{array}$


%The \textsf{shadow} function takes two same methods (with the same name and types of arguments), and return the method which shadows the other during inheritance.
%exmples to motivate our design
%interface A{static String m(){return "A";}}
%interface C extends A{
%	default String dm(){
%		  this.m();//wrong in java
%		  A.m();
%		  C.m();//wrong in java
%		}
%}
%
%
%(1) Static methods are not inherited. Also, if one of $\{body_1,body_2\}$ is null, \textsf{shadow} simply returns the other one. Hence

\begin{comment}
%Now it is correct, but may be we do not need it?
We abbreviate typing statements on
sequences in a simple way, writing $\Gamma \vdash \overline{t}:\overline{C}$ as
shorthand for $\Gamma \vdash t_1:C_1,..., \Gamma \vdash t_n:C_n$.
\end{comment}

\marco{The notation mtype get only non static methods, the notation mtypeS get only static ones}

%\subsubsection{Interface and method Typing}





\begin{comment}
\subsubsection{Method Typing}


\[
\inferrule
{ }
{T_0 \spc m(\overline{T} \spc \overline{x}); \text{ OK IN I} }
\quad \textsc{(T-Meth)}
\]

\[
\inferrule
{\overline{x}:\overline{T} \vdash e:S \\ S <: T_0}
{T_0 \spc m(\overline{T} \spc \overline{x}) \text{ \{ return } e;\} \text{ OK IN
    I} \\\\ \Gamma \vdash \textbf{this}:I }
\quad \textsc{(T-MethBody)}
\]

\[
\inferrule
{IT(I)=\text{interface } I \text{ extends } \overline{J} \text{\{...\}} \\
\forall i,\text{if \textsf{mtype}}(m,J_i) = \overline(T) \to U_0, \text{then }
T_0 <: U_0 }
{T_0 \spc m(\overline{T} \spc \overline{x}); \text{ OK IN I} }
\quad \textsc{(T-MethExt)}
\]

\[
\inferrule
{\textbf{this}:I, \overline{x}:\overline{T} \vdash e:S \\ S <: T_0 \\\\
IT(I)=\text{interface } I \text{ extends } \overline{J} \text{\{...\}} \\\\
\forall i,\text{if \textsf{mtype}}(m,J_i) = \overline(T) \to U_0, \text{then }
T_0 <: U_0 }
{T_0 \spc m(\overline{T} \spc \overline{x}) \text{ \{ return } e;\} \text{ OK IN
    I} }
\quad \textsc{(T-MethBodyExt)}
\]

\[ \inferrule
{\textbf{interface } I \textbf{ extends } \overline{J} \{ \overline{M} \} \\\\
 \forall J_i \in \overline{J}, J_i \text{ OK} \\\\
 \forall m \in \overline{M}, \textsf{mbody}(m,I) \neq \error \\\\
 \forall J_i \in \overline{J}, \forall m \text{ inside } J_i,
 \textsf{mbody}(m,I) \neq \error }
{I \text{ OK}}
\quad \textsc{(T-Intf)}
 \]

Interface $I$ type checks well, if:
\begin{itemize}
\item All its super-interfaces $\overline{J}$ OK.
\item All methods inside interface $I$ are OK.
\item All methods that $I$ is inheriting from super-interfaces are OK.
\end{itemize}
\subsubsection{Subtyping}

\[ \inferrule{}{T <: T} \]

\[ \inferrule{S <: T \\ T <: U}{S <: U}\]

\[ \inferrule{\emph{ann} \spc \textbf{interface} \spc C_0 \spc \textbf{extends} \spc C_1,...,C_k \{...\}}
{C_0 <: C_1 \\ ... \\ C_0 <: C_k} \]
\end{comment}
%\subsubsection{Interface Table}

\subsection{Method Overriding Mechanism}
We summarize the mechanism for method overriding below (all methods considered
here are methods with the same name and argument types):
\begin{enumerate}
\item Two abstract methods with subtyping relation do not cause conflict, and the
most specific one wins. Subtyping relation for two methods means they have the
same arguments' types and one return type is a subtype of the other one. For
example:
\begin{lstlisting}
interface A1 { Object m(); }
interface B1 { Integer m();}
interface C1 extends A1,B1 {} //accepted
\end{lstlisting}
Method \texttt{Integer m()} in \texttt{B} wins over method \texttt{Object m()}
in \texttt{A} because \texttt{Integer <: Object}.

\item A default method conflict with another default method or abstract method. For
example:
\begin{lstlisting}
interface A2 { default int m() {return 1;}}
interface B2 { int m(); }
interface C2 { default int m() {return 2;}}
interface D2 extends A2,B2 {} //rejected due to conflicting methods
interface E2 extends A2,C2 {} //rejected due to conflicting methods
\end{lstlisting}
Note how this is in contrast with what happens in most trait models, where \Q@D2@ would be accepted, and the implementation in \Q@A2@ would be part of the behaviour of \Q@D2@.

\item The method in the current interface wins over any methods defined in its
super-interfaces, provided that the method conform to the subtype of all methods
in its super-interfaces, i.e., the method is the most specific one. For example:
\begin{lstlisting}
interface D3 extends A2,B2 { int m(); } //accepted
interface E3 extends A2,C2 { int m(); } //accepted
\end{lstlisting}
\end{enumerate}
\subsection{Method Overriding Incoherence in Java}
% Please add the following required packages to your document preamble:
% \usepackage[table,xcdraw]{xcolor}
% If you use beamer only pass "xcolor=table" option, i.e. \documentclass[xcolor=table]{beamer}
While trying to formally encode the Java specification we have done some tests to clarify corner case behaviour.
Consider the following correct declarations:
\begin{lstlisting}
interface A1{T m(); }
interface A2 extends A1{default T m(){ ... } }
interface A3 extends A2{T m(); } 

interface B1{default T m(){ ... } }
interface B2 extends B1{T m(); }
interface B3 extends B2{default T m(){ ... } }
\end{lstlisting}

What happens if we define a new interface \Q@M@ implementing one \Q@A@${}_i$ and one \Q@B@${}_i$? we have 9 cases, that can fit nicely a table:\\*
\noindent
\begin{tabular}{|l|l|l|l|}
\hline
\textbf{M extends} & \textbf{A1}                  & \textbf{A2} & \textbf{A3} \\ \hline
\textbf{B1}        & conservative error                        & conflict error      & conservative error       \\ \hline
\textbf{B2}        & both abstract, accepted                        & conservative error       & both abstract, accepted       \\ \hline
\textbf{B3}        & \cellcolor[HTML]{C0C0C0} accepted? &conflict  error       & conservative error      \\ \hline
\end{tabular}
\\*
We try to classify the results out of the table:
\begin{itemize}
\item \textbf{conflict error} happens when the method from \Q@A@${}_i$ and one \Q@B@${}_i$ are both implemented. This is also considered an error in most trait models.
\item \textbf{both abstract, accepted} happens when the method from \Q@A@${}_i$ and one \Q@B@${}_i$ are both abstract. This is also considered correct in all trait models.
\item \textbf{conservative error}
 happens when the method from \Q@A@${}_i$ and one \Q@B@${}_i$ is implemented in only one side.
The is different from what we would expect in a trait model, but it may make sense with the conservative idea that a method defined in an interface
should not silently satisfy a method in another one.
\end{itemize}

We are very confused on the result for \textbf{B3},\textbf{A1}, and we can not find any rational for this behaviour.
\footnote{We refer to the behaviour of \texttt{javac} as in JDK version is\marco{add}.}

%Table~\ref{table:javabug} shows the method overriding bug in Java. In the
%example, there are 6 interfaces \texttt{A1,A2,A3,B1,B2,B3} with methods all
%named as \texttt{m} which are either abstract or default methods. If we define a
%new interface \texttt{M} that extends two of these interfaces, then the method
%overriding result is shown in the table. For example, row2 col2 means \texttt{M
%  extends A1,B1}. The result is \texttt{ERROR} because the abstract method
%\texttt{T m();} in \texttt{A1} conflicts with the method \texttt{default T m()
%  {...}} in \texttt{B1}. Readers may also figure out other extending cases by
%following this way of interpretation.

% The interesting case in row4 col2 where
To be coherent with the idea of \textbf{conservative error}, the case should not be accepted.
We do not see how this should behave differently from \textbf{B1},\textbf{A1}, and \textbf{B3},\textbf{A3}.
We fear that the only retro-compatible fix for this strange behaviour is to accept all the cases of \textbf{conservative error} in a future version of Java.
%the experimental result is \texttt{B3.m}. Because if we think consistently, this

%\lstinputlisting[linerange=4-9]{../UseMixinLombok/src/methodshadowing/test5/Test5.java} % APPLY:linerange=JAVABUG

In our approach, we choose to not model this strange behaviour (a bug?).
Our auxiliary function $\mBody(\m,\C)$ enforce the \textbf{conservative error} strategy.
The rest of our formalization is parametric with the definition of $\mBody(\m,\C)$, thus if Java change its resolution strategy to a more permissive one, only minor adaptations in $\mBody(\m,\C)$ would be needed.

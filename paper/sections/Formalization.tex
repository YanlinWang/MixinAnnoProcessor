\section{Formal Semantics}\label{sec:typesafety}
\marco{Tentative Grammar ClassLessJava}

\begin{figure}[h]
\begin{grammar}
\production{
\e
}{
  \x\mid\MCall\e\m\es\mid\MCall{\C}\m\es\mid\MCall{\C\QM{.super}}\m\es\mid\obj
  }{expressions}\\
\production{
\obj
}{
\QM{new}\ \C\oR\cR\oC\T_1\ \f_1\QM;\ldots\T_k\ \f_k\QM;\ 
\mh_1\oC\QM{return}\ \e_1\QM{;}\!\cC
\ldots
\mh_n\oC\QM{return}\ \e_n\QM{;}\!\cC
\cC
  }{object creation}\\
\production{
\metaVar{I}
}{
 \ann\ \QM{interface}\ \C_0\ \QM{extends}\ \C_1\ldots\C_k \oC\method_1\ldots\method_n\cC
  }{interface declaration}\\
\production{
\method
}{
 \QM{static}\ \mh\ \oC\QM{return}\ \e\QM{;}\!\cC
\mid 
\QM{default}\ \mh\oC\QM{return}\ \e\QM{;}\cC
\mid
\mh\QM{;}
  }{method declaration}\\
\production{
\mh
}{
 \T_0\ \m\ \oR\T_1\ \x_1\ldots\T_n\ \x_n\cR
  }{method header}\\
\production{
\ann
}{
  \mixinAnn|\emptyset
  }{annotations}\\
\end{grammar}
\caption{Grammar of ClassLess Java}
\label{Grammar}
\end{figure}

In Figure~\ref{Grammar} we show the syntax of ClassLess Java.

To be compatible with java, the concrete syntax for an interface declaration with empty supertype list $\C_1\ldots\C_k$ would also omit the \Q@extends@ keyword.

Yanlin and Haoyuan

We need to show 2 things:

1) The dynamic semantics: what's the code that gets generated by a mixin annotation;

2) The type system: what programs to reject; properties: generation of type-safe/checkable code.

\bruno{The implementation is still missing the type system (rejecting some
  programs)!}

Expression Typing:

\[
\inferrule{}{\Gamma \vdash x \in \Gamma(x)} \quad \textsc{(T-Var)}
\]

\[
\inferrule{\Gamma \vdash e_0 \in C_0 \\ 
  \textsf{mtype}(m,C_0) = \overline{D} \to E \\ 
  \Gamma \vdash \overline{e} \in \overline{C} \\
  \overline{C} <: \overline{D} }
{ \Gamma \vdash e_0.m(\overline{e}) \in E }
\quad \textsc{(T-Invk)}
\]

\[
\inferrule{\textsf{mtype}(m,C) = \overline{D} \to E \\
\Gamma \vdash \overline{e} \in \overline{C} \\
\overline{C} <: \overline{D} \\
\textsf{mmodifier}(m,C) = \textbf{static} }
{\Gamma \vdash C.m(\overline{e}) \in E}
\quad \textsc{(T-StaticInvk)}
\]

\[
\inferrule{\textsf{mtype}(m,C) = \overline{D} \to E \\
\Gamma \vdash \overline{e} \in \overline{C} \\
\overline{C} <: \overline{D} \\
\textsf{checkSuper}(C.super.m(\overline{e}), A, C) \\\\
\text{\yanlin{check whether A <: C, where A is the enclosing interface of the
    expression}} }
{\Gamma \vdash C.\textbf{super}.m(\overline{e}) \in E}
\quad \textsc{(T-SuperInvk)}
\]

Context:

\[ \Gamma = \epsilon \mid (x, C) : \Gamma  \]

Subtyping:

\[ \inferrule{}{T <: T} \]

\[ \inferrule{S <: T \\ T <: U}{S <: U}\]

\[ \inferrule{\emph{ann} \spc \textbf{interface} \spc C_0 \spc \textbf{extends} \spc C_1,...,C_k \{...\}}
{C_0 <: C_1 \\ ... \\ C_0 <: C_k} \]

Interface Table (IT):

A mapping from types \texttt{T} to interface declarations \texttt{L}. From the
interface table, we can read off the subtype relation between interfaces. The
subtype relation is given by the \textbf{extends} clauses in \texttt{IT}.

Auxiliary Definitions:

- \textsf{mtype(m, C)} : the signature of method m in C.

\[ \inferrule{
  IT(T) = \text{\emph{ann} interface } C \{ \overline{M} \} \\ 
  E \spc m(\overline{D} \spc \overline{x}) \{ \text{return } e; \} \in M}
{ \textsf{mtype(m,T)} = \overline{D} \to E } \]

\[ \inferrule{
  IT(T) = \text{\emph{ann} interface } C \{ \overline{M} \} \\ 
  m \notin M}
{ \textsf{mtype(m,T)} = \emptyset } \]




\[ \textsf{mmodifier(m, C)} = ? \]

\[ \textsf{mtype(m, C)} = ? \]

\[ \textsf{checksuper(C.super.m(e), A, C)} = ? \]

\yanlin{todo: add auxiliary functions}
\yanlin{todo: add subtyping rules}


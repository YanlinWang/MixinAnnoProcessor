\section{Formal Semantics}\label{sec:formal}
\subsection{Grammar}

\marco{Tentative Grammar ClassLessJava}

\begin{figure}[h]
\begin{grammar}
\production{
\e
}{
  \x\mid\MCall\e\m\es\mid\MCall{\C}\m\es\mid\MCall{\C\QM{.super}}\m\es\mid\obj
  }{expressions}\\
\production{
\obj
}{
\QM{new}\ \C\oR\cR\oC\T_1\ \f_1\QM;\ldots\T_k\ \f_k\QM;\
\mh_1\oC\QM{return}\ \e_1\QM{;}\!\cC
\ldots
\mh_n\oC\QM{return}\ \e_n\QM{;}\!\cC
\cC
  }{object creation}\\
\production{
\metaVar{I}
}{
 \ann\ \QM{interface}\ \C_0\ \QM{extends}\ \C_1\ldots\C_k \oC\method_1\ldots\method_n\cC
  }{interface declaration}\\
\production{
\method
}{
 \QM{static}\ \mh\ \oC\QM{return}\ \e\QM{;}\!\cC
\mid
\QM{default}\ \mh\oC\QM{return}\ \e\QM{;}\cC
\mid
\mh\QM{;}
  }{method declaration}\\
\production{
\mh
}{
 \T_0\ \m\ \oR\T_1\ \x_1\ldots\T_n\ \x_n\cR
  }{method header}\\
\production{
\ann
}{
  \mixinAnn|\emptyset
  }{annotations}\\
\end{grammar}
\caption{Grammar of ClassLess Java}
\label{Grammar}
\end{figure}

In Figure~\ref{Grammar} we show the syntax of ClassLess Java.

To be compatible with java, the concrete syntax for an interface declaration with empty supertype list $\C_1\ldots\C_k$ would also omit the \Q@extends@ keyword.

Yanlin and Haoyuan

We need to show 2 things:

1) The dynamic semantics: what's the code that gets generated by a mixin annotation;

2) The type system: what programs to reject; properties: generation of type-safe/checkable code.

\bruno{The implementation is still missing the type system (rejecting some
  programs)!}

\footnote{Future work: updating multiple fields in one method call,
  \texttt{with(T v)}}


\subsection{Typing Rules}
\subsubsection{Expression Typing}

\[
\inferrule{}{\Gamma \vdash x \in \Gamma(x)} \quad \textsc{(T-Var)}
\]

\[
\inferrule{\Gamma \vdash e_0 \in C_0 \\
  \textsf{mtype}(m,C_0) = \overline{D} \to E \\
  \Gamma \vdash \overline{e} \in \overline{C} \\
  \overline{C} <: \overline{D} }
{ \Gamma \vdash e_0.m(\overline{e}) \in E }
\quad \textsc{(T-Invk)}
\]

\[
\inferrule{\textsf{mtype}(m,C) = \overline{D} \to E \\
\Gamma \vdash \overline{e} \in \overline{C} \\
\overline{C} <: \overline{D} \\
\textsf{mmodifier}(m,C) = \textbf{static} }
{\Gamma \vdash C.m(\overline{e}) \in E}
\quad \textsc{(T-StaticInvk)}
\]

\[
\inferrule{\textsf{mtype}(m,C) = \overline{D} \to E \\
\Gamma \vdash \overline{e} \in \overline{C} \\
\overline{C} <: \overline{D} \\
\textsf{checkSuper}(C.super.m(\overline{e}), A, C) \\\\
\text{\yanlin{check whether A <: C, where A is the enclosing interface of the
    expression}} }
{\Gamma \vdash C.\textbf{super}.m(\overline{e}) \in E}
\quad \textsc{(T-SuperInvk)}
\]


\subsubsection{Method Typing} 
\[ 
\inferrule 
{ }
{T_0 \spc m(\overline{T} \spc \overline{x}); \text{ OK IN I} }
\quad \textsc{(T-Meth)}
\]

\[ 
\inferrule
{\overline{x}:\overline{T} \vdash e:S \\ S <: T_0}
{T_0 \spc m(\overline{T} \spc \overline{x}) \text{ \{ return } e;\} \text{ OK IN
    I} \\\\ \Gamma \vdash \textbf{this}:I }
\quad \textsc{(T-MethBody)}
\]

\[ 
\inferrule
{IT(I)=\text{interface } I \text{ extends } \overline{J} \text{\{...\}} \\
\forall i,\text{if \textsf{mtype}}(m,J_i) = \overline(T) \to U_0, \text{then }
T_0 <: U_0 }
{T_0 \spc m(\overline{T} \spc \overline{x}); \text{ OK IN I} }
\quad \textsc{(T-MethExt)}
\]

\[ 
\inferrule
{\overline{x}:\overline{T} \vdash e:S \\ S <: T_0 \\ 
IT(I)=\text{interface } I \text{ extends } \overline{J} \text{\{...\}} \\
\forall i,\text{if \textsf{mtype}}(m,J_i) = \overline(T) \to U_0, \text{then }
T_0 <: U_0 }
{T_0 \spc m(\overline{T} \spc \overline{x}) \text{ \{ return } e;\} \text{ OK IN
    I} \\\\ \Gamma \vdash \textbf{this}:I }
\quad \textsc{(T-MethBodyExt)}
\]

\subsubsection{Context}

\[ \Gamma = \epsilon \mid (x, C) : \Gamma  \]

\subsubsection{Subtyping}

\[ \inferrule{}{T <: T} \]

\[ \inferrule{S <: T \\ T <: U}{S <: U}\]

\[ \inferrule{\emph{ann} \spc \textbf{interface} \spc C_0 \spc \textbf{extends} \spc C_1,...,C_k \{...\}}
{C_0 <: C_1 \\ ... \\ C_0 <: C_k} \]

\subsubsection{Interface Table}
The Interface Table (IT) mapping from types \texttt{T} to interface declarations \texttt{L}. From the
interface table, we can read off the subtype relation between interfaces. The
subtype relation is given by the \textbf{extends} clauses in \texttt{IT}.


\subsection{Auxiliary Definitions}
\yanlin{todo: add more auxiliary functions}

\yanlin{todo: add interface context}

\begin{comment}
\subsubsection{Auxiliary function: \textsf{mtype}}
- \textsf{mtype(m, C)} : the signature of method m in C.

\[ \inferrule{
  IT(T) = \text{\emph{ann} interface } C \{ \overline{M} \} \\
  E \spc m(\overline{D} \spc \overline{x}) \{ \text{return } e; \} \in M}
{ \textsf{mtype(m,T)} = \overline{D} \to E } \]

\[ \inferrule{
  IT(T) = \text{\emph{ann} interface } C \{ \overline{M} \} \\
  m \notin M}
{ \textsf{mtype(m,T)} = \emptyset } \]

\[ \inferrule{
  IT(T) = \text{\emph{ann} interface } C \text{ extends } C_1,...,C_k \{ \overline{M} \} \\
  E \spc m(\overline{D} \spc \overline{x}) \{ \text{return } e; \} \in M}
{ \textsf{mtype(m,T)} = \overline{D} \to E } \]

\[ \inferrule{
  IT(T) = \text{\emph{ann} interface } C_0 \text{ extends } \overline{C} \{
  \overline{M} \} \\
  m \notin M}
{ \textsf{mtype(m,T)} = \bigcup \textsf{mtype}(m,\overline{D}) } \]
\end{comment}

\subsubsection{Auxiliary function: \textsf{mbody}}

$\textsf{mbody}(m,C)$ denotes the actual body of method $m$ that interface $C$ owns. It can either be defined originally in $C$ or in its supertypes, and then passed to $C$ via inheritance.

The body of a method $m$ contains the relevant information with respect to that method, like the type of $m$ as well as the modifier. Below shows how the functions $mtype$ and $mmodifier$ are derived from $mbody$.

\[ \textsf{mbody}(m,C) = \textit{modifier } E \spc m(\overline{D} \spc \overline{x}) \{ \text{return } e; \} \] \[ \Rightarrow \textsf{mtype}(m,C) = \overline{D} \to E,\ \textsf{mmodifier}(m,C) = \textit{modifier}\]

\[ \inferrule{
  IT(C) = \text{\emph{ann} interface } C \{ \overline{M} \} \\
  m \notin M}
{ \textsf{mbody}(m,C) = \emptyset } \]

\[ \inferrule{
  IT(C) = \text{\emph{ann} interface } C \{ \overline{M} \} \\
  m \in M}
{ \textsf{mbody}(m,C) = m } \]

\[ \inferrule{
  IT(C_0) = \text{\emph{ann} interface } C_0 \text{ extends } \overline{C} \{
  \overline{M} \} \\
  m \notin M
  }
{ \textsf{mbody}(m,C_0) = \textsf{fold}_\textsf{shadow}\cdot\textsf{map}_{\textsf{mbody,}m}\cdot\textsf{subset}(\overline{C}) } \]

\[ \inferrule[(ReviewedRule)]{
  IT(C_0) = \text{\emph{ann} interface } C_0 \text{ extends } \overline{C} \{
  \methods \} \\
  \methods(\m)=\method
\\
\Aux{tops}(\overline{C})=\C_1\ldots\C_n  
  }
{ \mBody(\m,\C_0) = \textsf{replace}(\method, \shadow(\mBody(\m,C_1)\ldots\mBody(\m,C_n))
 } \]
\subsubsection{Auxiliary function: \Aux{tops}}

\[ \textsf{tops}(\Cs)=\{\ \C\in\Cs\ |\ \nexists \C'\in\Cs\setminus\C,\ \C' \subtype \C\ \} \]

\subsubsection{Auxiliary function: \textsf{shadow}}



The \textsf{shadow} function takes two same methods (with the same name and types of arguments), and return the method which shadows the other during inheritance.
%exmples to motivate our design
%interface A{static String m(){return "A";}}
%interface C extends A{
%	default String dm(){
%		  this.m();//wrong in java
%		  A.m();
%		  C.m();//wrong in java
%		}
%}
%
%
%(1) Static methods are not inherited. Also, if one of $\{body_1,body_2\}$ is null, \textsf{shadow} simply returns the other one. Hence
\begin{equation*}
\begin{array}{ll}
\shadow()=\emptyset\\
\shadow(\methods)=\method &\mif\ \method \in \methods, \forall \method' \in \methods\setminus\method :  \method' \subtype  \method,\\
\mbox{ otherwise}\\
\shadow(\methods)=\conflicted\mh&\mif\ \shadow(\Aux{removeBody}(\methods))=\mh\\
\Aux{removeBody}(\QM{default}\ \mh\mbox{\Q@\{return \_;\}@})
=\mh\QM;\\
\Aux{removeBody}(\mh\QM)
=\mh\QM;
\\
%\conflictError \shadow \_\\
\_\subtype\emptyset\\
%\mh\mbox{\Q@\{return \_;\}@}\shadow \mh & \mif\ \mh\shadow\mh'\\
\_\ \mh\mbox{\Q@\{return \_;\}@}\subtype \mh & \mif\ \mh\subtype\mh'\\

\T \m\oR\T_1\x_1\ldots \T_n\x_n\cR \subtype \T' \m\oR\T_1\x_1'\ldots\T_n\x_n'\cR & \mif\ \T\subtype \T'\\
\Aux{replace}(\method,\emptyset)=
\Aux{replace}(\emptyset,\method)=\method\\
\Aux{replace}(\method,\_\ \mh\mbox{\Q@\{return \_;\}@})
=

\\
%\textsf{shadow}(body_1, body_2)=\emptyset & \textsf{if }body_1.\textsf{modifier}=body_2.\textsf{modifier}=\textbf{static}\\
%\textsf{shadow}(body_1, body_2)=body_1 & \textsf{if }body_2=\emptyset\textsf{ or }body_2.\textsf{modifier}=\textbf{static}\\
%\textsf{shadow}(body_1, body_2)=body_2 \hspace{.1in}  & \textsf{if }body_1=\emptyset\textsf{ or }body_1.\textsf{modifier}=\textbf{static}
\end{array}
\end{equation*}

%(2) If $body_1.\textsf{returnType}=body_2.\textsf{returnType}$, \textsf{shadow} tends to return a default method. If both $body_1$ and $body_2$ are default methods, \textsf{shadow} throws an error.
%\begin{equation*}
%\begin{array}{ll}
%\textsf{shadow}(body_1, body_2)=\textsf{ERROR} & \textsf{if }body_1.\textsf{modifier}=body_2.\textsf{modifier}=\textbf{default}\\
%\textsf{shadow}(body_1, body_2)=body_1 \hspace{.1in} & \textsf{if }body_1.\textsf{modifier}=\textbf{default} \\
%\textsf{shadow}(body_1, body_2)=body_2 \hspace{.1in} & \textsf{if }body_2.\textsf{modifier}=\textbf{default} \\
%\textsf{shadow}(body_1, body_2)=body_1\textsf{ (or }body_2\textsf{)} \hspace{.1in} & \textsf{otherwise}
%\end{array}
%\end{equation*}
%
%(3) If $body_1.\textsf{returnType}<:body_2.\textsf{returnType}$, \textsf{shadow} tends to choose the one with the subtype (namely $body_1$), but only when both methods are abstract, otherwise it gives an error. The other direction $body_2.\textsf{returnType}<:body_1.\textsf{returnType}$ follows the same rule. It also gives an error if there is no subtyping relationship between two return types.
%\begin{equation*}
%\begin{array}{ll}
%\textsf{shadow}(body_1, body_2)=body_1 & \textsf{if }body_1.\textsf{modifier}=body_2.\textsf{modifier}=\emptyset\\
%& \textsf{and }body_1.\textsf{returnType}<:body_2.\textsf{returnType}\\
%\textsf{shadow}(body_1, body_2)=body_2 & \textsf{if }body_1.\textsf{modifier}=body_2.\textsf{modifier}=\emptyset\\
%& \textsf{and }body_2.\textsf{returnType}<:body_1.\textsf{returnType}\\
%\textsf{shadow}(body_1, body_2)=\textsf{ERROR} \hspace{.1in} & \textsf{otherwise}
%\end{array}
%\end{equation*}

\subsubsection{Auxiliary function: \textsf{replace}}

The \textsf{replace} function takes two same methods (with the same name and types of arguments), and gives the result of the first method overriding the second one.

\begin{equation*}
\begin{array}{ll}
\textsf{replace}(body_1, body_2)=body_1 & \textsf{if }body_2=\emptyset\\
\textsf{replace}(body_1, body_2)=body_2 & \textsf{if }body_1=\emptyset\\
\textsf{replace}(body_1, body_2)=body_1 & \textsf{if }body_1.\textsf{returnType}<:body_2.\textsf{returnType}\\
\textsf{replace}(body_1, body_2)=\textsf{ERROR} \hspace{.1in} & \textsf{otherwise}
\end{array}
\end{equation*}



\section{Appendix}\label{sec:appendix}

\subsection{LEMMA 1 and Proof}\label{subsec:proof1}
\textbf{LEMMA 1. }
Assume that
\begin{align*}
\II_0\ &=\ \mixinAnn\ \QM{interface}\ \C_0\ \QM{extends}\ \Cs\ \oC \methods\ \cC\\
[\![\II_0]\!]\ &=\ \emptyset\ \QM{interface}\ \C_0\ \QM{extends}\ \Cs\ \oC \methods\ \methods' \cC
\end{align*}
If $\II_0$ satisfies $\dom(\C_0)=\dom(\C_1)\cup\ldots\cup\dom(\C_n)\cup\dom(\methods)$, then $[\![\II_0]\!]$ satisfies $\dom([\![\II_0]\!])=\dom(\C_1)\cup\ldots\cup\dom(\C_n)\cup\dom(\methods)\cup\dom(\methods')$.
\begin{proof}
It suffices to prove $\dom([\![\II_0]\!])=\dom(\C_0)\cup\dom(\methods')$.
\begin{itemize}
\item If $m\notin\dom(\methods')$, by the definition of $\mBody$, it is obtained from $\override$. The first argument of $\override$, namely $\methods\cup\methods'(m)$, is equal to $\methods(m)$, and the second argument is not changed as well, thus the result of $\override$ is not changed during translation. Hence $m\in\dom([\![\II_0]\!])$ iff $m\in\dom(\C_0)$.
\item If $m\in\dom(\methods')$, we are to prove $m\in\dom([\![\II_0]\!])$. So if $m$ is the $\QM{of}$ method generated by $\ofMethod$, its $\mBody$ value is well defined, by the rule $\override(\method,\none)=\method$.\marco{need to add here that we know of is not in dom(..)}\haoyuan{BTW, the condition of the translation should be $\QM{of}\notin\dom(\methods)$ or $\QM{of}\notin\dom(\C_0)$?} On the other hand, if $m$ is generated by $\otherMethod$, namely $m$ is a $\QM{with-}$ or setter method,
 we can apply the last clause of override, since in the definition of $\otherMethod$, we can see $\isWith$ and $\isSetter$ ensure the compatible subtyping relationship. Hence $m\in\dom([\![\II_0]\!])$ as well.
\end{itemize}
\end{proof}

\marco{ we need to state (may be as a new lemma):
forall expressions e, if under interface table I0,I1..In
$\Gamma\vdash e\in\C$, then  under interface table [[I0]],I1..In
$\Gamma\vdash e\in\_<:\C$
ProofScatch:
(1) observing otherMethods(), we see that [I] is structurally a subtype of I, thus all the expressions typed in an interface table with I, are well typed in an interface table with [I].
The only interesting case is method call (normal, super and static)
consider $\Gamma\vdash e_0.m(e_1..e_n)\in\C$, with $e_0$ of type I0,
if it is well typed in the first table, then in the other table it is still well typed:
the method still exists and its argument types are the same type.
The expressions 1..n may be now typed in a subtype, but this is ok since the premise of the rule ask for $\_<:\C$
}

\subsection{LEMMA 2 and Proof}\label{subsec:proofs}
\textbf{LEMMA 2. }
For any expression $e$ under an interface table $\II_0\ldots\II_n$ with $\Gamma\vdash e\in\C$, if $[\![\II_0]\!]$ is well-defined, then under the interface table $[\![\II_0]\!]\II_1\ldots\II_n$, $\Gamma\vdash e\in\_<:\C$.
\begin{proof}
The proof is based on induction. By the grammar shown in Figure~\ref{Grammar}, there are three cases for an arbitrary expression $e$:
\begin{itemize}
\item A variable or a field update. The type preservation for $e$ is ensured by induction.
\item A method call (normal, static or super). Such a method won't be ``removed'' by the translation and is still there, and the types of arguments remain unchanged. The only difference is that the return type can be refined, in which case the expression $e$ is typed in a subtype of $I$.?
\item An object creation.
\end{itemize}
\end{proof}

\subsection{Proof of LEMMA 2}\label{subsec:proof2}
\textbf{LEMMA 2. }
If $\II_0$ OK, then $[\![\II_0]\!]$ OK.
\begin{proof}

By the rule \rn{t-Intf} in Figure~\ref{ET}, we divide it into two parts.

\noindent\textbf{Part I.} For each default or static method in the domain of $[\![\II_0]\!]$, the type of the return value is compatible with the method's return type.

Since $\II_0$ OK, \marco{by newLemma} all the existing default and static methods are well typed in $[\![\II_0]\!]$, except for the new method \QM{of}. It suffices to prove that it still holds for $\ofMethod(\C_0)$.


By the definition of $\ofMethod(\C_0)$, the return value is an object $$\QM{return new}\ \C_0 \oR\cR\ \QM{\{}...\ \QM{\}}$$
To prove it is of type $\C_0$, we use the typing rule \rn{t-Obj}.

\haoyuan{The order of conditions in \rn{t-Obj} is not clear below.}

\begin{itemize}
\item For field typing,
\[\Gamma(\QM_ m_i)=\C_i\subtype \C_i\]
\item For method typing of getters,
\[\Gamma, m_i:\C_i, \QM{this}:\C_0, \Gamma^{\mh_i}\vdash m_i\in \C_i\]
We know that $\C_i=\C^{\mh_i}$ since...\marco{finish}.
\item For method typing of \QM{with-} methods, by \rn{t-StaticInvk}, \haoyuan{how to do typing for the generated method itself?}
\marco{the next judgement is not ok, state something like:
We consider the with method for a arbitrary i field.
In this case the method body we have to type would be...
and here you can replace $e_i$ with the correct specialized expression}
\[\Gamma, \overline{m_i:\C_i}, \QM{this}:\C_0, \es_i:\Cs_i, \Gamma^{\mh_i}\vdash \C_0\QM{.of}\oR\es_i\cR\in \C_0\]
We know that $\C_0=C^{\mh_i}$ since ..\marco{ finish}
\item For method typing of setter methods, \haoyuan{what about the \QM{with} method?}\marco{we do not formalize it}
\[\Gamma, \QM{this}:\C_0, \Gamma^{\mh_i}\vdash\QM{this}\in \C_0=\C^{\mh_i}\]
\marco{no, you also need to show that the part x=var is correct, and again push I= out}
\marco{for under, now that the explanation have been improved, use the names of the new auxiliary functions}
\item To prove that $\forall i$, $\mh_i\subtype\mBody(m^{\mh_i}, \C_0)$,
 \begin{itemize}
 \item For getters, \[\C_i\ m_i\oR\cR\QM; \in \fieldsFunc(\C_0) \Rightarrow \C_i\ m_i\oR\cR\QM; \in \dom(\C_0)\]
 \item For \QM{with-} methods,\marco{ use if-then or other english forms instead of the logic arrow}
  \[\begin{array}{l}
  \mBody(\QM{with#}\m_i,\C_0) \mbox{ is of form }\mh\QM; \\ \valid(\C_0)
  \end{array}\Rightarrow \isWith\Rightarrow \C_0\subtype\mBody(m^{\mh_i}, \C_0)\]
 \item For setters,
  \[\begin{array}{l}
  \mBody(\m_i,\C_0) \mbox{ is of form }\mh\QM; \\ \valid(\C_0)
  \end{array}\Rightarrow \isSetter\Rightarrow \C_0\subtype\mBody(m^{\mh_i}, \C_0)\]
 \end{itemize}
\item To prove that such a created object indeed implements all the abstract methods in $\dom(\C_0)$, we simply refer to $\valid(\C_0)$, since it guarantees each abstract method $\method$ to satisfy $\isField$, $\isWith$ or $\isSetter$. But that object includes all implementations for those cases, hence it is of type $\C_0$ by \rn{t-Obj}.
\end{itemize}

\noindent\textbf{Part II.} Next we check that in $[\![\II_0]\!]$, $$\dom([\![\II_0]\!])=\dom(\C_1)\cup\ldots\cup\dom(\C_n)\cup\dom(\methods)\cup\dom(\methods')$$
And actually it is guaranteed by \textbf{LEMMA 1}.
\marco{may be you may just delete lemma1 and put its proof here?}

\end{proof}

\subsection{Proof of THEOREM}\label{subsec:proof3}
\textbf{THEOREM. }
For a given $\II_0\ldots\II_n$ interface table such that
$\forall\II\in\II_0\ldots\II_n, \II$ OK, then in the interface table
$[\![\II_0]\!]\II_1\ldots\II_n$
$\forall\II\in[\![\II_0]\!]\II_1\ldots\II_n$ either $\II$ OK or $\II$ is a subtype of $\II_0$.
\begin{proof}
\textbf{LEMMA 2} already proves that $[\![\II_0]\!]$ is OK. On the other hand, if some $\II$ is not a subtype of $\II_0$,
\marco{by the newLemma, we know that all its methods are still well typed, and } the generated code in translation has no way to affect the domain of $\II$,\marco{ so rule t-interf can still be applied,} which finishes our proof.
\end{proof}

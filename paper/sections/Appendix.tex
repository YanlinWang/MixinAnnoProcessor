\section{Appendix}\label{sec:appendix}

\textbf{THEOREM. }
For a given $\II_0\ldots\II_n$ interface table such that
$\forall\II\in\II_0\ldots\II_n, \II$ OK,\\*
if $\II_0$ has \textbf{@ObjWeak},
$\valid(\C_0)$  and $\QM{of}\notin\dom(\C_0)$,
then in the interface table
$[\![\II_0]\!]\II_1\ldots\II_n$\\*
$\forall\II\in[\![\II_0]\!]\II_1\ldots\II_n$ $\II$ OK.\\

\noindent For convenience, assume that
\begin{align*}
\II_0\ &=\ \weakAnn\ \QM{interface}\ \C_0\ \QM{extends}\ \Cs\ \oC \methods\ \cC\\
[\![\II_0]\!]\ &=\ \emptyset\ \QM{interface}\ \C_0\ \QM{extends}\ \Cs\ \oC \methods\ \method' \cC
\end{align*}

\subsection{LEMMA 1 and Proof}\label{subsec:lemma1}

\textbf{LEMMA 1. }
For any expression $e$ under an interface table $\II_0\ldots\II_n$ with $\Gamma\vdash e\in\C$, if $\II_0$ has \textbf{@ObjWeak} and $[\![\II_0]\!]$ is well-defined, then under the interface table $[\![\II_0]\!]\II_1\ldots\II_n$, $\Gamma\vdash e\in\_<:\C$.
\begin{proof}
The proof is based on induction. By the grammar shown in Figure~\ref{Grammar}, there are three cases for an arbitrary expression $e$:
\begin{itemize}
\item A variable or a field update. The type preservation for $e$ is ensured by induction.
\item A method call (normal, static or super). Such a method won't be ``removed'' by the translation and is still there, and the types remain unchanged. The only work \textbf{@ObjWeak} does is adding a static method $\QM{of}$ to the interface, however, a pre-condition of the translation is $\QM{of}\notin\dom(\C_0)$, so adding $\QM{of}$ method has no way to affect any method call.
\item An object creation. Adding the $\QM{of}$ method doesn't introduce unimplemented methods to an interface, moreover, the static method is not inheritable, hence after translation such an object creation still type checks and has the right type by induction.
\end{itemize}
\end{proof}

\subsection{LEMMA 2 and Proof}\label{subsec:lemma2}

\textbf{LEMMA 2. }
If $\II_0$ has \textbf{@ObjWeak} and is OK, then $[\![\II_0]\!]$ OK.
\begin{proof}

By the rule \rn{t-Intf} in Figure~\ref{ET}, we divide the proof into two parts.

\noindent\textbf{Part I.} For each default or static method in the domain of $[\![\II_0]\!]$, the type of the return value is compatible with the method's return type.

Since $\II_0$ OK, and by \textbf{LEMMA 1}, all the existing default and static methods are well typed in $[\![\II_0]\!]$, except for the new method \QM{of}. It suffices to prove that it still holds for $\ofMethod(\C_0)$.


By the definition of $\ofMethod(\C_0)$, the return value is an object $$\QM{return new}\ \C_0 \oR\cR\ \QM{\{}...\ \QM{\}}$$
To prove it is of type $\C_0$, we use the typing rule \rn{t-Obj}.

\begin{itemize}
\item All field initializations are type correct. By the definition of $\ofMethod(\C_0)$ in Section~\ref{subsec:ofmethod}, the fields $m_1,\ldots,m_n$ are initialized by $\QM{of}$'s arguments, and types are compatible.
\item All method bodies are well-typed.
    \begin{itemize}
    \item Typing of the $i$-getter $m_i$. \[\Gamma, m_i:\C_i, \QM{this}:\C_0 \vdash m_i\in \C_i\]
        We know that $\C_i=\C^{\mh_i}$ since the $i$-th getter has its return type the same as the corresponding field $m_i$.
    \item Typing of the \QM{with-} method of an arbitrary field $m_i$. By Section~\ref{subsec:ofmethod}, if the \QM{with-} method of $m_i$ is well-defined, it has the form \[\C_0\ \QM{with#}\m_i\oR \C_i\ \QM{_val}\cR\ \QM{\{}\QM{return}\ \C_0\QM{.of(}\es_i\QM{);\}}\]
        $\es_i$ is obtained by replacing $m_i$ with $\QM{_val}$ in the list of fields, and since they have the same type $\C_i$, the arguments $\es_i$ are compatible with $\C_0.\QM{of}$ method. Hence \[\Gamma, \overline{m_i:\C_i}, \QM{this}:\C_0,\ \QM{_val} : \C_i \vdash \C_0\QM{.of}\oR\es_i\cR\in \C_0\]
        We know that $\C_0=\C^{\mh_i}$ by the return type of $\QM{with#}\m_i$ shown as above.
    \item Typing of the $i$-setter \QM_$m_i$. If the \QM_$m_i$ method is well-defined, it has the form
        \[\C_0\ \QM_\m_i\oR \C_i\ \QM{_val}\cR\ \QM{\{} \m_i\QM{= _val;return this;\}}\]
        By \rn{t-Update}, the assignment ``$\m_i\QM{= _val;}$'' is correct since $\m_i$ and $\QM{_val}$ have the same type $I_i$, and the return type is decided by \QM{this}. \[\Gamma, \QM{this}:\C_0,\ \QM{_val} : \C_i \vdash\QM{this}\in \C_0\]
        We know that $\C_0=\C^{\mh_i}$ by the return type of $\QM_\m_i$ shown as above.\\
        \haoyuan{Can we write $\Gamma, \QM{this}:\C_0,\ \QM{_val} : \C_i, \C^{\mh_i} = \C_0 \vdash\QM{this}\in \C_0 = \C^{\mh_i}$?}\\
        \haoyuan{Can we write $\QM{\{} \m_i\QM{= _val;return this;\}} \in \C_0$?}
    \end{itemize}
\item All method headers are valid with respect to the domain of $\C_0$. Namely $$\sigvalid(\mh_1\ldots\mh_n,I)$$
    \haoyuan{TODO}
\item All abstract methods in the domain of $\C_0$ have been implemented. Namely $$\alldefined(\mh_1\ldots\mh_n,I)$$
    Here we simply refer to $\valid(\C_0)$, since it guarantees each abstract method to satisfy $\isField$, $\isWith$ or $\isSetter$. But that object includes all implementations for those cases, hence it is of type $\C_0$ by \rn{t-Obj}.
\end{itemize}

\noindent\textbf{Part II.} Next we check that in $[\![\II_0]\!]$, $$\dom([\![\II_0]\!])=\dom(\C_1)\cup\ldots\cup\dom(\C_n)\cup\dom(\methods)\cup\dom(\method')$$
Since $\II_0$ OK, we have $\dom(\II_0)=\dom(\C_1)\cup\ldots\cup\dom(\C_n)\cup\dom(\methods)$, and hence it is equivalent to prove $$\dom([\![\II_0]\!])=\dom(\C_0)\cup\dom(\method')$$
This is obvious since a pre-condition of the translation is $\QM{of}\notin\dom(\C_0)$, so $\method'$ doesn't overlap with $\dom(\C_0)$. The definition of $\dom$ is based on $\mBody$, and here the new domain $\dom([\![\II_0]\!])$ is only an extension to $\dom(\C_0)$ with the \QM{of} method, namely $\method'$, which finishes our proof.
\end{proof}

\subsection{Notes}

\begin{itemize}
\item To prove that $\forall i$, $\mh_i\subtype\mBody(m^{\mh_i}, \C_0)$,
 \begin{itemize}
 \item For getters, \[\C_i\ m_i\oR\cR\QM; \in \fieldsFunc(\C_0) \Rightarrow \C_i\ m_i\oR\cR\QM; \in \dom(\C_0)\]
 \item For \QM{with-} methods,\marco{ use if-then or other english forms instead of the logic arrow}
  \[\begin{array}{l}
  \mBody(\QM{with#}\m_i,\C_0) \mbox{ is of form }\mh\QM; \\ \valid(\C_0)
  \end{array}\Rightarrow \isWith\Rightarrow \C_0\subtype\mBody(m^{\mh_i}, \C_0)\]
 \item For setters,
  \[\begin{array}{l}
  \mBody(\m_i,\C_0) \mbox{ is of form }\mh\QM; \\ \valid(\C_0)
  \end{array}\Rightarrow \isSetter\Rightarrow \C_0\subtype\mBody(m^{\mh_i}, \C_0)\]
 \end{itemize}
\end{itemize}


\subsection{Proof of THEOREM}\label{subsec:proof3}
\textbf{THEOREM. }
For a given $\II_0\ldots\II_n$ interface table such that
$\forall\II\in\II_0\ldots\II_n, \II$ OK, then in the interface table
$[\![\II_0]\!]\II_1\ldots\II_n$
$\forall\II\in[\![\II_0]\!]\II_1\ldots\II_n$ either $\II$ OK or $\II$ is a subtype of $\II_0$.
\begin{proof}
\textbf{LEMMA 2} already proves that $[\![\II_0]\!]$ is OK. On the other hand, if some $\II$ is not a subtype of $\II_0$,
\marco{by the newLemma, we know that all its methods are still well typed, and } the generated code in translation has no way to affect the domain of $\II$,\marco{ so rule t-interf can still be applied,} which finishes our proof.\haoyuan{And the well-formedness.}
\end{proof}

\section{Case studies}
Haoyuan and Yanlin

\subsection{A Trivial Solution to the Expression Problem}

The \emph{Expression Problem} (EP)~\cite{wadler98expression-problem} is coined
by Wadler about modular extensibility issues in software evolution and has been
a hot topic in programming languages since. Today we know of various solutions
to the EP that either rely on \emph{new programming language
  features}~\cite{chambers95multimethods,clifton00multiJava,madsen89virtual,nystrom06j,bruce98astatically,McDirmid01jiazzi,garrigue98polymorphic,zenger01extensible,loh06open,wehr11javaGI},
or can be used as \emph{design patterns}~\cite{gof} in existing
languages~\cite{torgersen04theexpression,oliveira06extensible,wouter08datatypes,oliveira09modular,oliveira12extensibility}. In
this paper we show that the EP can be solved with our \mixin annotation in a
trivial way. We will use a canonical example of implementing arithmetic
expressions gradually to illustrate the usage. 

\subsubsection{Initial System}
The initial system expresses arithmetic expressions with only literals and
addition structure:

\lstinputlisting[linerange=25-35]{../UseMixinLombok/src/test/TestExpression.java}% APPLY:linerange=EXPRESSION_INIT

\texttt{Exp} is the common super-interface with an evaluation operation
\texttt{eval()} inside. Sub-interfaces \texttt{Lit} and \texttt{Add} extend
interface \texttt{Exp} with default implementations for \texttt{eval}
operation. The number field (\texttt{x}) of a literal is represented as a getter
method \texttt{x()} and expression fields (\texttt{e1,e2}) of an addition as
getter methods \texttt{e1()} and \texttt{e2()}.

\subsubsection{Adding a New Variant}
It is easy to add new data variants to the code in the initial system in a
modular way. For example, the following code how to add the subtraction variant.

\lstinputlisting[linerange=39-44]{../UseMixinLombok/src/test/TestExpression.java}% APPLY:linerange=EXPRESSION_SUB


\subsubsection{Adding a New Operation}
Adding new operations to the previous system is still straightforward (although
requires longer code). The following code shows an example of adding a new
operation \texttt{print}. 

\lstinputlisting[linerange=48-57]{../UseMixinLombok/src/test/TestExpression.java}% APPLY:linerange=EXPRESSION_PRINT

The basic idea is to define interfaces for extending old interfaces.  The
interface \texttt{ExpP} extending interface \texttt{Exp} is defined with the
extra function \texttt{print()}. Interfaces \texttt{LitP} and \texttt{AddP} are
defined with default implementations of operation \texttt{print()}, extending
base interfaces \texttt{Lit} and \texttt{Add}, respectively. Importantly, note
that in \texttt{AddP}, the types of ``\emph{fields}'' \texttt{e1,e2} are refined via
the \emph{return types refinement} of getter methods \texttt{e1()} and
\texttt{e2()}. 


\subsection{A Small Game Example}
We now present a variant of a classic game example, which is often used to
evaluate reuse ability related to inheritance and design patterns. The code
using our approach and the solution by Bono et. al~\cite{bono14} in online, for
space constraints, we will omit it here. In the game, there is a player with the
goal of collecting as many coins as possible. She may enter a room with several
doors to be chosen among. This is a good example because it involves code reuse
(different kinds of doors inherit a common type, with different features and
behaviour), multiple inheritance (a special kind of door may require features
from two other door types). It also shows how to model symmetric sum, override
and alias as trait-oriented programming. Moreover, the code is provided in
~\cite{bono14} so that we can have a clear and fair comparison with our
approach, as shown in Table~\ref{table:codereduction}.

\begin{table}[h]
\centering
\begin{tabular}{ccc}
\hline
            & SLOC   & \# of classes/interfaces \\ \hline
Bono et al. & 335    & 14                       \\
Ours        & 199    & 11                       \\
\rowcolor[HTML]{C0C0C0} 
Reduced by  & 40.6\% & 21.4\%                   \\ \hline
\end{tabular}
\caption{Code Reduction and Reuse.}
\label{table:codereduction}
\end{table}


\subsection{Other case studies}
\marco{should we put here the DB with fluent setters?}

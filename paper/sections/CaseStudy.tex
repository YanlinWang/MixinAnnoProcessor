\section{Case Studies}
In this section we conduct three case studies which reveals various advantages
using \mixin annotation. The first case study provides a easy and
straightforward way to solve the Expression Problem. The second one models a
simple game and the comparison between our approach and others shows that code
amount is reduced tremendously using \mixin. The third one models an embedded
DSL for SQL languages with fluent interfaces and shows that \mixin not only
removes verbol code for defining fluent interfaces but also does implicit
refinement along extension.

\subsection{A Trivial Solution to the Expression Problem}

The \emph{Expression Problem} (EP)~\cite{wadler98expression-problem} is coined
by Wadler about modular extensibility issues in software evolution and has been
a hot topic in programming languages since. The requirements of a solution to
the EP can be summarized as: 
\begin{itemize}
\item \emph{Extensibility in both dimensions}: A solution must allow
  the addition of new data variants and new operations and support
  extending existing operations.
\item \emph{Strong static type safety}: A solution must prevent
  applying an operation to a data variant which it cannot handle using
  static checks.
\item \emph{No modification or duplication}: Existing code must not be
  modified nor duplicated.
\item \emph{Separate compilation and type-checking}: Safety checks or
  compilation steps must not be deferred until link or runtime.
\item \emph{Independent extensibility}~\cite{zenger05independentlyextensible}:
  It should be possible to combine independently developed extensions so that
  they can be used jointly.
\end{itemize}

Today we know of various solutions to the EP that either rely on \emph{new
  programming language features}
% ~\cite{chambers95multimethods, clifton00multiJava, madsen89virtual, nystrom06j,
%   bruce98astatically, McDirmid01jiazzi, garrigue98polymorphic,
%   zenger01extensible, loh06open, wehr11javaGI}, 
or can be used as \emph{design patterns}%~\cite{gof}
in existing languages. 
% ~\cite{torgersen04theexpression, oliveira06extensible,
%  wouter08datatypes, oliveira09modular, oliveira12extensibility}. 
A new solution~\cite{eptrivially} based on covariant type refinement solves EP
and works in Java-like languages. It does not introduce new language features,
does not even require generics support. However one of the limitation is certain
code verbosity caused by ``Final'' classes for instantiation. Now we show that
our \mixin annotation helps to remove these mechanical code in a trivial way. We
will use the canonical example of implementing arithmetic expressions gradually
as in \cite{eptrivially} to illustrate the usage.

\paragraph{Initial System}
The initial system expresses arithmetic expressions with only literals and
addition structure:

\lstinputlisting[linerange=34-44]{../UseMixinLombok/src/test/TestExpression.java}% APPLY:linerange=EXPRESSION_INIT

\texttt{Exp} is the common super-interface with an evaluation operation
\texttt{eval()} inside. Sub-interfaces \texttt{Lit} and \texttt{Add} extend
interface \texttt{Exp} with default implementations for \texttt{eval}
operation. The number field (\texttt{x}) of a literal is represented as a getter
method \texttt{x()} and expression fields (\texttt{e1,e2}) of an addition as
getter methods \texttt{e1()} and \texttt{e2()}.

\paragraph{Adding a New Variant}
It is easy to add new data variants to the code in the initial system in a
modular way. For example, the following code shows how to add the subtraction
variant.

\lstinputlisting[linerange=48-53]{../UseMixinLombok/src/test/TestExpression.java}% APPLY:linerange=EXPRESSION_SUB


\paragraph{Adding a New Operation}
Adding new operations to the previous system is still straightforward (although
requires longer code). The following code shows an example of adding a new
operation \texttt{print}.

\lstinputlisting[linerange=57-66]{../UseMixinLombok/src/test/TestExpression.java}% APPLY:linerange=EXPRESSION_PRINT

The basic idea is to define interfaces for extending old interfaces.  The
interface \texttt{ExpP} extending interface \texttt{Exp} is defined with the
extra function \texttt{print()}. Interfaces \texttt{LitP} and \texttt{AddP} are
defined with default implementations of operation \texttt{print()}, extending
base interfaces \texttt{Lit} and \texttt{Add}, respectively. Importantly, note
that in \texttt{AddP}, the types of ``\emph{fields}'' \texttt{e1,e2} are refined
via the \emph{return types refinement} of getter methods \texttt{e1()} and
\texttt{e2()}.

\paragraph{Independent Extensibility}
To show that our approach supports independent extensibility, we first define a
new operation \texttt{collectLit}(which collects all
literal components in an expression) on expressions: 

\lstinputlisting[linerange=70-86]{../UseMixinLombok/src/test/TestExpression.java}% APPLY:linerange=EXPRESSION_COLLECTLIT

\noindent Now we combine the two extensions (\texttt{print} and
\texttt{collectLit}) together:

\lstinputlisting[linerange=90-94]{../UseMixinLombok/src/test/TestExpression.java}% APPLY:linerange=INDEPENDENT_EXTENSIBILITY

\noindent \texttt{ExpPC} is the new expression interface supporting
\texttt{print} and \texttt{collectLit} operations; \texttt{LitPC} and
\texttt{AddPC} are the extended variants. Notice that except for the routine of
\textbf{extends} clauses, no glue code is required. Return types of
\texttt{e1,e2} are also automatically refined to \texttt{ExpPC}.

\subsection{A Small Game Example}
We now present a variant of a classic game example, which is often used to
evaluate code reuse ability related to inheritance and design patterns. The code
using our approach and the solution by Bono et. al~\cite{bono14} in online, for
space constraints, we will omit it here. In the game, there is a player with the
goal of collecting as many coins as possible. She may enter a room with several
doors to be chosen among. This is a good example because it involves code reuse
(different kinds of doors inherit a common type, with different features and
behaviour), multiple inheritance (a special kind of door may require features
from two other door types) and it also shows how to model operations
\texttt{symmetric sum}, \texttt{override} and \texttt{alias} as trait-oriented
programming. Moreover, the code is provided in ~\cite{bono14} so that we can
have a clear and fair comparison with our approach, as shown in
Table~\ref{table:codereduction}. We reduced the interfaces/classes used by
21.4\% (from 14 to 11) due to the replacement of instantiation classes with
generated \texttt{of} methods. We reduced source lines of code (SLOC) by
40\%. To ensure a fair comparison, we use the same code style as Bono's.

\begin{table}[h]
\centering
\begin{tabular}{ccc}
\hline
            & SLOC   & \# of classes/interfaces \\ \hline
Bono et al. & 335    & 14                       \\
Ours        & 199    & 11                       \\
\rowcolor[HTML]{C0C0C0} 
Reduced by  & 40.6\% & 21.4\%                   \\ \hline
\end{tabular}
\caption{Code Reduction and Reuse.}
\label{table:codereduction}
\end{table}


\subsection{Embedded DSLs with Fluent Interfaces}
Since the style of fluent interfaces was invented in Smalltalk as method
cascading, more and more languages came to support fluent interfaces, including
JavaScript, Java, C++, D, Ruby, Scala, etc. For most languages, to create fluent
interfaces, programmers have to either handwritten everything or create a
wrapper around the original non-fluent interfaces, using \textbf{this}. In Java,
several libraries help create fluent APIs easily (by code generation), including
jOOQ, op4j, fluflu, JaQue, etc. These libraries have given us hints on the
implementation of fluent setters in ClassLess Java.

When creating fluent interfaces, our approach has two main advantages:
\begin{enumerate}
\item Instead of forcing programmers to hand write code using \textbf{return
    this}, our approach with \mixin annotation removes this verbosity and
  automatically generate fluent setters.
\item Along the extension direction, the return types of fluent setters are
  automatically refined.
\end{enumerate} 

\noindent We use embedded DSLs of two simple SQL query languages to illustrate.
The first query language \texttt{Database} (conceptually) models
\texttt{select}, \texttt{from} and \texttt{where} clause:
\lstinputlisting[linerange=6-13]{../UseMixinLombok/src/jooq/DatabaseTest.java}% APPLY:linerange=FLUENT_DATABASE

\noindent Note that we are only illustrating the idea of modeling embedded DSLs
with the database example, no concrete implementation of database connection nor
operations are provided in this case study. One benefit that fluent methods give
us is method chaining convenience. So when making a query using \texttt{select},
\texttt{from} and \texttt{where}, instead of writing code like:
\lstinputlisting[linerange=26-29]{../UseMixinLombok/src/jooq/DatabaseTest.java}% APPLY:linerange=NORMAL_QUERY

\noindent We can write more concise code below:
\lstinputlisting[linerange=35-38]{../UseMixinLombok/src/jooq/DatabaseTest.java}% APPLY:linerange=FLUENT_QUERY1

\noindent Now we extend the first query language with a new feature
\texttt{orderBy} which orders the result records by a field that users
specified. The key is to extend interface \texttt{Database} with only the
feature we need to add and the return type of fluent setters in
\texttt{Database} is automatically refined to \texttt{ExtendedDatabase}:
\lstinputlisting[linerange=17-20]{../UseMixinLombok/src/jooq/DatabaseTest.java}% APPLY:linerange=FLUENT_DATABASE_EXT

% \lstinputlisting[linerange=44-48]{../UseMixinLombok/src/jooq/DatabaseTest.java}% APPLY:linerange=FLUENT_QUERY2



\section{Related Work}\label{sec:related}
In this section we discuss related work and comparison to Classless Java.




%\yanlin{need to discuss: whether the comments for FTJ is fair.}

%No, was not fair, I know that work, it does modular type checking, and 
%more work after that they extend with more safe/modular typing things.
%also, Java8 IS a language extension on Java
%However, language extensions (including FTJ)
%have a natural drawback: the programmer has to learn new syntax. In contrast,
%our approach is completely compatible with the current Java language, so that
%programmers don't need to pay any learning cost to adapt to this new classless
%programming pattern. Another drawback which is particular for FTJ is that FTJ
%doesn't have type for traits, hence the correctness check of trait is done when
%type-checking classes. This choice makes the design of FTJ simpler but lost
%typechecking efficiency (one trait will be potentially checked multiple times if
%it is used in multiple classes).

\subsection{Multiple Inheritance in Object oriented languages}
Many authors have argued in favour or against multiple inheritance.
It provides expressive power, but it is difficult to model, and implement and can create programs that are hard to reason about.
These difficulties include the famous
diamond (fork-join) problem~\cite{bracha90mixin,Sak89dis}, conflicting methods, and the yo-yo problem~\cite{taenzer1989problems}.
\marco{add citation on the text over.}
\yanlin{added.}
To conciliate the need for expressive power and the need for simplicity, 
lots of models have been proposed in the past few
years, including mixins~\cite{bracha90mixin} and traits~\cite{scharli03traits}.
They provide novel programming architecture models in the
OO paradigm. 
\begin{enumerate}
\item  Mixins allows to name components that can be applied to various classes as
reusable functionality units. However,  they suffer from linearisation: the order of mixin application is relevant in often subtitle and undesired ways. constraints. This hinders their
usability and their ability of resolving conflicts:
 the linearisation (total ordering) of mixin inheritance cannot provide a satisfactory resolution in all cases and restricts the flexibility of mixin composition.

 To fight those limitations, an algebra of mixin operators is introduced~\cite{CMS-elena-zucca-davide-ancona}, but this raised the complexity of the approach, especially when constructors and fields are considered~\cite{Ecoop-FJigsaw-marco}.

\item 
Simplifying the mixin algebras approach, traits draw a strong line between units of reuse (traits) and object factories (classes)
In this model, traits~\cite{Scharli2003} units of reusable code,  containing only methods as
reusable functionalities. Thus, no state/state initialization is considered.

Classes act as object factories, requiring functionalities from multiple traits.
Traits offers a trait algebra  with operations like sum, alias and exclusion, provided for explicit conflict resolution.


Concluding, (pure) traits do not allow state and they do not offers any reuse instrument to ensure that state is coherently initialized when finally defined in classes.
Traits can't be instantiated. This model requires two concepts (traits and classes) to coexist and cooperate.

Some authors see this as good language design fostering good software development by helping programmers to think about the structure of their programs.
However, other authors see the need of two concepts and the absence of state as drawbacks of this model.

\item C++ and Scala also try to provide solutions to multiple inheritance, but both
suffer from object initialization problems. Virtual inheritance in C++ provides
another solution to multiple inheritance (especially the diamond problem by
keeping only one copy of the base class)~\cite{ellis1990annotated}, however
suffers from object initialization problem as pointed out by Malayeri et
al.~\cite{malayeri2009cz}. It bypasses all constructor calls to virtual
superclasses, which would potentially cause serious semantic error. Scala
solution (very similar to linearised mixins, but misleadingly called traits in the language) avoids this problem by disallowing constructor parameters,
causing no ambiguity in cases such as diamond problem. 
This approach has limited expressiveness, and suffers from all the problems of linearised mixin composition.
Python also offers multiple inheritance via linearised mixins. Indeed python any class is implicitly a mixin, and mixin composition informally expressed as\\*
\Q@ class A use B,C {...new methods...}@\\*
can be expressed in python as \\*
\Q@ class Aux: ...new methods...@\\*
\Q@ class A(B,C,Aux):  pass@ 
\end{enumerate}

\subsection{Multiple Inheritance in Java}
Since Java 8 default methods are introduced, which enables concrete method
implementation to be defined (via the \textbf{default} keyword) inside
interfaces. Since Java supports implementation of multiple interfaces (instead of extension of a single
class), the introduction of default methods opens the gate for various flavours of multiple
inheritance in Java, using interfaces. 
Former work by Bono.et. al.~\cite{bono14}.
provides details on mimicking traits~\cite{sharly-thesis} through interfaces.


There are proposals for extending Java (before Java8) with traits. For example, FeatherTrait
Java (FTJ)~\cite{Liquori08ftj} by Liquori et al. extends the calculus of
Featherweight Java (FJ)~\cite{Igarashi01FJ} with statically-typed traits, adding
trait-based inheritance in Java.
Except for few, mostly syntactic details, their work can be emulated/rephrased with Java8 interface.


\input{sections/Compare.tex}

\subsection{ThisType/MyType/Extensibility}
%\marco{ this section is unfair. There are unsolved problems with ThisType in negative positions, namelly it breaks subtyping. The most common solution is to allow calling some methods only when the exact type is known. This demolish most advantages of interfaces.}

In certain situations, our approach allows automatic refinement for return types. This is part of a bigger topic in class based languages: expressing and preserving type recursion and (nominal/structural) subtyping at the same time. 

One famous attempt in this direction is provided by 
\emph{MyType}~\cite{bruce1994paradigmatic}, representing the type of \textbf{this}, changing its meaning along with
inheritance.
However when invoking a method with MyType in a parameter position, the exact type of the receiver must be known.
This is huge limitation in class based object oriented programming,
and is exasperated by interface-only programming as we propose: no type is ever exact since classes are not part of the language.
A recent article~\cite{igarashi Matching MyType to subtyping}
lights up this topic, since
they propose two features: exact statements and non-inheritable methods; both related to our work:
any method generated inside of the \Q@of@ method is indeed non-inheritable, since there is no class name to extends from, and exact statements (a form of wild-card capture on the exact run-time type)
could capture the ``exact type'' of an object even in a class-less environment.



% The addition of MyType to a language will allow easy definition of
%binary methods, methods with recursive types (i.e., the same type of the
%receiver appears in the argument or return positions of methods), etc. MyType
%greatly enhances the expressiveness and extensibility of object-oriented
%programming languages. 

%In our approach, we are using covariant-return types to simulate some uses of
%MyType. But our approach only works on method positive positions, whereas MyType
%is more general, as it works on any positions. Nevertheless our approach is
%still useful for modeling fluent interfaces and solving expression
%problems,etc. 

\subsection{Type-Directed Translations/Syntactic Sugar}
Language extensions are often implemented as syntactic sugar of the base
language. For example, Scala compiler supports XML syntax in normal Scala code
directly (after Scala ?, users need to import \texttt{scala-xml} library
manually). However, this approach is hard in terms of implementation, because it
requires extending the compiler. Also, this approach does not support combining
multiple extensions into one.

SugarJ~\cite{erdweg11sugarj} is a Java-based extensible programming language
that allows programmers to extend the base language with custom language
features by definitions in meta-DSLs (SDF, Stratego, etc). 
\yanlin{Is new syntax really a ``drawback''? I think for some system, like
  SugarJ, one of purpose IS to introduce these new syntax.}  Drawbacks: new
syntax. To create the extension, programmers have to work with multiple
languages (SDF, stratego, etc) while our approach works totally in Java
environment.

We can model certain types of language extensions with annotations 
only, but those extensions do not introduce new syntax: they 
merely do automatic code generation. 

\subsection{Meta-programming techniques}
- MetaFJig*~\cite{}
\yanlin{Maybe Marco can help with the text for MetaFJig?}

Annotations/Code Generation/Lombok

What is the difference between our work and existing annotations?
What is it that we can do that, those annotations cannot?

-Lombok~\cite{} project provides a set of predefined annotations, including
constructor generators similar as ours (\textbf{@NoArgsConstructor},
\textbf{@RequiredArgsConstructor} and \textbf{@AllArgsConstructor}). They
generate various kinds of constructors for \emph{classes}, with or without
constructor arguments. This set of annotations is of great use, especially when
they are used together with other features provided in Lombok (e.g.,
\textbf{@Data}). Moreover, the implementation of these annotations in Lombok
gives us hints on how to implement \mixin. However, none of these annotations
can model what we are doing with \mixin - generating a constructor for
\emph{interfaces}. Apart from constructors, \mixin also provides other
convenient features (including generating fluent setters, type refinement,etc)
that the base Lombok project could not provide.

\subsection{Fluent Interfaces}
Talk about existing libraries that use fluent interfaces (do any of
those use any code generation to assist in the implementation?).

Since the style of fluent interfaces was invented in Smalltalk as method
cascading, more and more languages came to support fluent interfaces, including
JavaScript, Java, C++, D, Ruby, Scala, etc. For most languages, to create fluent
interfaces, programmers have to either handwritten everything or create a
wrapper around the original non-fluent interfaces, using \textbf{this}. In Java,
several libraries help create fluent APIs easily (by code generation), including
jOOQ, op4j, fluflu, JaQue, etc. These libraries have given us hints on the
implementation of fluent setters in ClassLess Java.

\subsection{Formalization of Java8}
We provide a simple and well designed formalization for a subset of Java including default/static interface methods and object initialization literals (often called anonymous local inner classes).
A similar formalization was drafted by\marco{ I use the term draft because I seams to remember it was just a technical report, I'm right?}
Goetz and Field~\cite{goetz12fdefenders} to formalize defender (default) methods
in Java. However this formalization is limited to model exactly one
method inside classes/interfaces.

As a evidence of the attention and care present in our formalization work, while double-checking the behaviour of Java in side cases we have discovered a likely bug in the current \texttt{javac}.\marco{refer to before when we explain the issue.}

\section{Future work}

\subsection{Private state}
The biggest limitation of our approach is the absence in Java8 of support for private/protected methods in interfaces.That is, in Java8 all members of interfaces are public, including static methods.
Since we use abstract methods to encode the state, our state is always all public; however is impossible for the user to know if a certain method maps directly to a field or if it have a default implementation.
If the use wants a constructor that does not directly maps to the fields, (as for secondary constructors in Scala) he can simply define its own \Q@of@ method and delegate on the generated one, as in
\begin{lstlisting}
@Mixin interface Point{
  int x(); int y();
  static Point of(int val){return Point.of(val,val);}  
  }
\end{lstlisting}
However, the generated \Q@of@ method would also be present and public.
If a future version of Java was to support \emph{static private methods in interfaces} we could extend our code generation to handle also encapsulation.
Currently, is possible to use a public nested class with private static methods inside, but this is ugly and cumbersome. We are considering if our annotation processor can take code with \Q!@Private! annotation and turn it into static private methods of a nested class. In this extension,  also the of method could be made private following the same pattern. 

\subsection{State initialization}

As discuss before, the user can trivially define its own \Q@of@ method, and initialize a portion of the state with default values.
However, the initialization code would not be reused/reusable, and subinterfaces would have to repeat such initialization code.
If a field has no setters, a simple alternative is to just define the ``field'' as a default method as in 
\begin{lstlisting}
@Mixin interface Box{ default int val(){return 0;} }
\end{lstlisting}
if setters are required, a possible extension of our code expansion could recognize a field if the getter is provided and the setter is required, and could generate the following code:
\begin{lstlisting}
interface Box{ 
  default int val(){return 0;} 
  void val(int _val);
  static Box of(){return new Box(){
    int val=Box.super.val();
    int val(){return val;}
    void val(int _val){val=_val;}
    };}}
\end{lstlisting}
We are unsure of the value of this solution: is very tricky, the user define a method that (contrary to our usual expectation) is actually overridden in a way that the behaviour change, but change only after the first setter is called, plus this code would cache the result instead of re-computing it every time. This can be very relevant and tricky in a non functional setting.

\subsection{Class invariants in ClassLess Java}
Since the objects are created by automatically generate methods,
another limitation of our current approach is that there is no place where the user can dynamically check for class invariants.
In Java often we see code like
\begin{lstlisting}
class Point{ int x; int y;
  Point(int x; int y){this.x=x;this.y=y; assert this.checkInvariant();}
  private boolean checkInvariant(){... x>0,y>0...}
\end{lstlisting} 

We are considering an extension of our annotation where 
default methods with the special name \Q@checkInvariant()@ will be called inside of the \Q@of@ methods.
if multiple interfaces are implemented, and more then one offers
\Q@checkInvariant()@,  a composed implementation could be automatically generated, composing by \Q@&&@ the various competing implementations.

\subsection{Clone, toString, equals and hashCode}
Methods originally defined in \Q@Object@, as \Q@clone@ and \Q@toString@ can be supported by our approach, but they need special care. If an interface annotated with \mixin ask an implementation for \Q@clone@, \Q@toString@ \Q@equls@ or \Q@hashCode@ we can easily generate one from the fields.\footnote{In particular, for clone we can do automatic return type refinement as we do for \Q@with-@ and fluent setters. Note how this would solve most of the Java ugliness related to \Q@clone@ methods.}

However, if the user wish to provide its own implementation, since the method is also implemented in \Q@Object@ we would have a conflict, that we have to explicitly resolve inside of \Q@of@, by implementing the method and delegating it to the user implementation, thus

\begin{lstlisting}
@Mixin interface Point{ int x(); int y();
  default Point clone(){ return Point.of(0,0);}//user defined clone
  }
\end{lstlisting} 
Would expand into 

\begin{lstlisting}
interface Point{ int x(); int y();
  default Point clone(){ return Point.of(0,0);}//user defined clone
  public static Point of(int _x,int_y){
    return new Point(){...
      public Point clone(){ return Point.super.clone();}
      };  }  }
\end{lstlisting} 

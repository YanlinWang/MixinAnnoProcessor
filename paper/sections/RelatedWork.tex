\section{Related Work}\label{sec:related}
In this section we discuss related work and comparison to Classless Java.

\subsection{Multiple Inheritance in Java}
Since Java 8 default methods are introduced, which enables concrete method
implementation to be defined (via the \textbf{default} keyword) inside
interface. Since in Java supports extension on multiple interfaces (instead of
classes), the introduction of default methods opens the gate of doing multiple
inheritance in Java by using interfaces. Details on achieving multiple
inheritance by mimicking trait programing through interfaces are summarized by
Bono.et. al.~\cite{bono14}. There is also formalization proposed by
Goetz and Field~\cite{goetz12fdefenders} to formalize defender (default) methods
in Java. However this formalization is limited since they only model exactly one
method inside classes/interfaces, where in our formalization multiple methods
may be defined.

\yanlin{need to discuss: whether the comments for FTJ is fair.}
There are proposals for extending Java with traits. For example, FeatherTrait
Java (FTJ)~\cite{Liquori08ftj} by Liquori et al. extends the calculus of
Featherweight Java (FJ)~\cite{Igarashi01FJ} with statically-typed traits, adding
trait-based inheritance in Java. However, language extensions (including FTJ)
have a natural drawback: the programmer has to learn new syntax. In contrast,
our approach is completely compatible with the current Java language, so that
programmers don't need to pay any learning cost to adapt to this new classless
programming pattern. Another drawback which is particular for FTJ is that FTJ
doesn't have type for traits, hence the correctness check of trait is done when
type-checking classes. This choice makes the design of FTJ simpler but lost
typechecking efficiency (one trait will be potentially checked multiple times if
it is used in multiple classes).

\subsection{Multiple Inheritance in General}
Multiple inheritance is a great feature to have in a programming language, but
it is difficult to model and implement. These difficulties include the famous
diamond (fork-join) problem, conflicting methods, yo-yo problem, etc. In order
to model multiple inheritance, lots of models have been proposed in the past few
years, including mixins~\cite{bracha90mixin} and traits~\cite{scharli03traits}.
Both traits and mixins provide novel models of new programming architecture in
object oriented programming paradigm. 

1) Mixins model named components that can be applied to various classes as
reusable functionality units. However, the well-known limitation of mixins is
that they suffer from linearization constraints, which hinders the
expressiveness of mixins and the ability of resolving conflicts.  As shown in
section~\ref{sec:comparison}, although they solved some multiple inheritance
problems, they are extremely restricting expressiveness. 

2) Traits are a novel model to differentiate two functionalities out of classes:
units of reusable components and object factories. In trait models, traits are
responsible for units of reusable components, which contain pure methods as
reusable functionalities; whereas classes act as object factories, which
requires various functionalities from multiple traits. However drawbacks of
traits are obvious: traits do not allow state; traits can't be instantiated
directly.

3) C++ and Scala also try to provide solutions to multiple inheritance, but both
suffer from object initialization problems. Virtual inheritance in C++ provides
another solution to multiple inheritance (especially the diamond problem by
keeping only one copy of the base class)~\cite{ellis1990annotated}, however
suffers from object initialization problem as pointed out by Malayeri et
al.~\cite{malayeri2009cz}. It bypasses all constructor calls to virtual
superclasses, which would potentially cause serious semantic error. Scala
solution (traits) avoids this problem by disallowing constructor parameters,
causing no ambiguity in cases such as diamond problem. The drawback of this
elegant design is limited expressiveness. 

\paragraph{ThisType/MyType/Extensibility}
Typical object-oriented programming languages (e.g. Java) use class names as
types and inheritance as subtyping relations. This gives difficulty when
extending classes/interfaces with recursive types. Problems such as binary
methods, return type refinement, etc. emerge and hinders software extensibility
greatly.

\emph{MyType}~\cite{bruce1994paradigmatic} was proposed by Bruce and Foster,
which represents the type of \textbf{this} and changes its meaning along with
inheritance. The addition of MyType to a language will allow easy definition of
binary methods, methods with recursive types (i.e., the same type of the
receiver appears in the argument or return positions of methods), etc. MyType
greatly enhances the expressiveness and extensibility of object-oriented
programming languages. 

In our approach, we are using covariant-return types to simulate some uses of
MyType. But our approach only works on method positive positions, whereas MyType
is more general, as it works on any positions. Nevertheless our approach is
still useful for modeling fluent interfaces and solving expression
problems,etc. 

\paragraph{Type-Directed Translations/Syntactic Sugar}

- SugarJ~\cite{erdweg11sugarj}

We can model certain types of language extensions with annotations 
only, but those extensions do not introduce new syntax: they 
merely do automatic code generation. 

\paragraph{Meta-programming techniques}
- MetaFJig*

Annotations/Code Generation/Lombok

What is the difference between our work and existing annotations? 
What is it that we can do that, those annotations cannot?

\paragraph{Fluent Interfaces}

Talk about existing libraries that use fluent interfaces (do any of 
those use any code generation to assist in the implementation?). 



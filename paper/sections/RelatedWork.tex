\section{Related Work}\label{sec:related}
In this section we discuss related work and comparison to Classless Java.




%\yanlin{need to discuss: whether the comments for FTJ is fair.}

%No, was not fair, I know that work, it does modular type checking, and 
%more work after that they extend with more safe/modular typing things.
%also, Java8 IS a language extension on Java
%However, language extensions (including FTJ)
%have a natural drawback: the programmer has to learn new syntax. In contrast,
%our approach is completely compatible with the current Java language, so that
%programmers don't need to pay any learning cost to adapt to this new classless
%programming pattern. Another drawback which is particular for FTJ is that FTJ
%doesn't have type for traits, hence the correctness check of trait is done when
%type-checking classes. This choice makes the design of FTJ simpler but lost
%typechecking efficiency (one trait will be potentially checked multiple times if
%it is used in multiple classes).

\subsection{Multiple Inheritance in Object Oriented Languages}
Many authors have argued in favour or against multiple inheritance.  It provides
expressive power, but it is difficult to model and implement, and can create
programs that are hard to reason about.  These difficulties include the famous
diamond (fork-join) problem~\cite{bracha90mixin,Sak89dis}, conflicting methods, etc.
%and the yo-yo problem~\cite{taenzer1989problems}.  
To conciliate the need for
expressive power and the need for simplicity, lots of models have been proposed
in the past few years, including mixins~\cite{bracha90mixin} and
traits~\cite{scharli03traits}.  They provide novel programming architecture
models in the OO paradigm.

\begin{enumerate}
\item Mixins allows to name components that can be applied to various classes as
  reusable functionality units. However, they suffer from linearisation: the
  order of mixin application is relevant in often subtitle and undesired
  ways. constraints. This hinders their usability and their ability of resolving
  conflicts: the linearisation (total ordering) of mixin inheritance cannot
  provide a satisfactory resolution in all cases and restricts the flexibility
  of mixin composition.  To fight those limitations, an algebra of mixin
  operators is introduced~\cite{ancona2002calculus}, but this raised the
  complexity of the approach, especially when constructors and fields are
  considered~\cite{marco09FJigsaw}.  Our approach does not have the
  linearisation problem, in that the semantics of Java \textbf{extends} clause
  is unordered and symmetric.
\item Simplifying the mixin algebras approach, traits draw a strong line between
  units of reuse (traits) and object factories (classes) In this model,
  traits~\cite{scharli03traits} units of reusable code, containing only methods
  as reusable functionalities. Thus, no state/state initialization is
  considered.

  Classes act as object factories, requiring functionalities from multiple
  traits.  Traits offers a trait algebra with operations like sum, alias and
  exclusion, provided for explicit conflict resolution.

  Concluding, (pure) traits do not allow state and they do not offers any reuse
  instrument to ensure that state is coherently initialized when finally defined
  in classes.  Traits can't be instantiated. This model requires two concepts
  (traits and classes) to coexist and cooperate.

  Some authors see this as good language design fostering good software
  development by helping programmers to think about the structure of their
  programs.  However, other authors see the need of two concepts and the absence
  of state as drawbacks of this model. Our approach takes interfaces as units of
  reuse, and meanwhile generates factory method for instantiation.

\item C++ and Scala also try to provide solutions to multiple inheritance, but
  both suffer from object initialization problems. Virtual inheritance in C++
  provides another solution to multiple inheritance (especially the diamond
  problem by keeping only one copy of the base class)~\cite{ellis1990annotated},
  however suffers from object initialization problem as pointed out by Malayeri
  et al.~\cite{malayeri2009cz}. It bypasses all constructor calls to virtual
  superclasses, which would potentially cause serious semantic error. Scala
  solution (very similar to linearised mixins, but misleadingly called traits in
  the language) avoids this problem by disallowing constructor parameters,
  causing no ambiguity in cases such as diamond problem.  This approach has
  limited expressiveness, and suffers from all the problems of linearised mixin
  composition.
  Python also offers multiple inheritance via linearised mixins. Indeed in python any class is implicitly a mixin, and mixin composition informally expressed as\\*
  \Q@ class A use B,C {...new methods...}@\\*
  can be expressed in python as \\*
  \Q@ class Aux: ...new methods...@\\*
  \Q@ class A(B,C,Aux): pass@
  Our approach not only does not involve linearised mixin problem, but also
  support proper constructor mechanism.
\end{enumerate}

\subsection{Multiple Inheritance in Java}
Since Java 8 default methods are introduced, concrete method implementation are
allowed to be defined (via the \textbf{default} keyword) inside
interfaces. 
% Since Java supports implementation of multiple interfaces (instead
% of extension of a single class), 
The introduction of default methods opens the
gate for various flavours of multiple inheritance in Java, using interfaces.
Former work by Bono.et. al.~\cite{bono14}. provides details on mimicking traits
through interfaces.

There are proposals for extending Java (before Java8) with traits. For example,
FeatherTrait Java (FTJ)~\cite{Liquori08ftj} by Liquori et al. extends the
calculus of Featherweight Java (FJ)~\cite{Igarashi01FJ} with statically-typed
traits, adding trait-based inheritance in Java.  Except for few, mostly
syntactic details, their work can be emulated/rephrased with Java8 interface.


\input{sections/Compare.tex}

\subsection{ThisType/MyType/Extensibility}
%\marco{ this section is unfair. There are unsolved problems with ThisType in negative positions, namelly it breaks subtyping. The most common solution is to allow calling some methods only when the exact type is known. This demolish most advantages of interfaces.}

In certain situations, our approach allows automatic refinement for return types. This is part of a bigger topic in class based languages: expressing and preserving type recursion and (nominal/structural) subtyping at the same time. 

One famous attempt in this direction is provided by
\emph{MyType}~\cite{bruce1994paradigmatic}, representing the type of
\textbf{this}, changing its meaning along with inheritance.  However when
invoking a method with MyType in a parameter position, the exact type of the
receiver must be known.  This is huge limitation in class based object oriented
programming, and is exasperated by interface-only programming as we propose: no
type is ever exact since classes are not part of the language.  A recent
article~\cite{Saito2013933} lights up this topic, since they propose two
features: exact statements \yanlin{do we support exact statements?}\marco{no we do not. When is that it may seams we do?} and
non-inheritable methods; both related to our work: any method generated inside
of the \Q@of@ method is indeed non-inheritable, since there is no class name to
extends from, and exact statements (a form of wild-card capture on the exact
run-time type) could capture the ``exact type'' of an object even in a
class-less environment.



% The addition of MyType to a language will allow easy definition of
%binary methods, methods with recursive types (i.e., the same type of the
%receiver appears in the argument or return positions of methods), etc. MyType
%greatly enhances the expressiveness and extensibility of object-oriented
%programming languages. 

%In our approach, we are using covariant-return types to simulate some uses of
%MyType. But our approach only works on method positive positions, whereas MyType
%is more general, as it works on any positions. Nevertheless our approach is
%still useful for modeling fluent interfaces and solving expression
%problems,etc. 

\begin{comment}
\subsection{Type-Directed Translations/Syntactic Sugar}
\marco{I'm tring to merge this and the next one}
Language extensions are often implemented as syntactic sugar of the base
language. For example, Scala compiler supports XML syntax in normal Scala code
directly (after Scala ?, users need to import \texttt{scala-xml} library
manually). However, this approach is hard in terms of implementation, because it
requires extending the compiler. Also, this approach does not support combining
multiple extensions into one.

SugarJ~\cite{erdweg11sugarj} is a Java-based extensible programming language
that allows programmers to extend the base language with custom language
features by definitions in meta-DSLs (SDF, Stratego, etc). 
\yanlin{Is new syntax really a ``drawback''? I think for some system, like
  SugarJ, one of purpose IS to introduce these new syntax.}  Drawbacks: new
syntax. To create the extension, programmers have to work with multiple
languages (SDF, stratego, etc) while our approach works totally in Java
environment.

We can model certain types of language extensions with annotations 
only, but those extensions do not introduce new syntax: they 
merely do automatic code generation. 
\end{comment}
\subsection{Meta-programming competes with Language extensions}
The most obvious solution to add features to a language is language extension.
They are often implemented as syntactic extensions that can be desugared to the base
language. For example, the Scala compiler was extended to directly supports XML syntax. However, this approach does not support combining multiple extensions into one. We are de facto creating a fork in the language, and rarely the new fork gain enough traction to become the main language release.
On this topic we mention SugarJ~\cite{erdweg11sugarj}; a Java-based extensible language allowing programmers to extend it with custom features by definitions in meta-DSLs (SDF, Stratego, etc). 

On the other side, when the starting language have a flexible enough syntax and a fast and powerful enough reflection, we may just need to play with operator overloading and other language tricks to discover that the language feature we need can be expressed as a simple library in our language. For example, consider SQL alchemy in python.

Java-like language tends to sits in the middle of this two extremes:
libraries can not influence the type system, so many solutions valid in python or other languages could not be applicable, or may be applicable at the cost of loosing safety.

Here (compile/load time) code generation come at the rescue: 
if for a certain feature (\mixin in our case) it is possible to use the original language syntax to
\emph{express-describe} any specific instantiation of such feature
(annotating a class and provide getters), then we can insert in the compilation process a tool that exam and enrich the code before compilation. No need to modify the original source; for example we can work on temporary files.
Java is a particular good candidate for this kind of manipulation since it already provide ways to define and integrate such tools in its own compilation process: in this way there is no need of temporary files, and there is a well defined way of putting multiple extensions together.

Other languages offers even stronger support to safe code manipulation:
Template Haskell~\cite{}, F\# (type providers)~\cite{} and MetaFjig (Active Libraries)~\cite{}
all allows to execute code at compile time and to generate code/classes that are transparently integrated in the program that is being generated/processed/compiled.
In particular, MetaFjig offers a property called \emph{meta-level-soundness}. In short this property ensures by construction that library code (even if wrong or non nonsensical) would never generate ill-typed code. This is roughly equivalent to what we state and manually proof in Lemma 2 for our particular transformation.
Since MetaFjig is not working on annotated classes, there is no direct equivalence on the overall theorem of safety we shown.

\subsection{Formalization of Java8}
We provide a simple and well designed formalization for a subset of Java including default/static interface methods and object initialization literals (often called anonymous local inner classes).
A similar formalization was drafted by\marco{ I use the term draft because I seams to remember it was just a technical report, I'm right?}
Goetz and Field~\cite{goetz12fdefenders} to formalize defender (default) methods
in Java. However this formalization is limited to model exactly one
method inside classes/interfaces.

As a evidence of the attention and care present in our formalization work, while double-checking the behaviour of Java in side cases we have discovered a likely bug in the current \texttt{javac}.\marco{refer to before when we explain the issue.}

\section{Future work}

\subsection{Private state}
The biggest limitation of our approach is the absence in Java8 of support for private/protected methods in interfaces.That is, in Java8 all members of interfaces are public, including static methods.
Since we use abstract methods to encode the state, our state is always all public; however is impossible for the user to know if a certain method maps directly to a field or if it have a default implementation.
If the use wants a constructor that does not directly maps to the fields, (as for secondary constructors in Scala) he can simply define its own \Q@of@ method and delegate on the generated one, as in
\begin{lstlisting}
@Mixin interface Point{
  int x(); int y();
  static Point of(int val){return Point.of(val,val);}  
  }
\end{lstlisting}
However, the generated \Q@of@ method would also be present and public.
If a future version of Java was to support \emph{static private methods in interfaces} we could extend our code generation to handle also encapsulation.
Currently, is possible to use a public nested class with private static methods inside, but this is ugly and cumbersome. We are considering if our annotation processor can take code with \Q!@Private! annotation and turn it into static private methods of a nested class. In this extension,  also the of method could be made private following the same pattern. 

\subsection{State initialization}

As discuss before, the user can trivially define its own \Q@of@ method, and initialize a portion of the state with default values.
However, the initialization code would not be reused/reusable, and subinterfaces would have to repeat such initialization code.
If a field has no setters, a simple alternative is to just define the ``field'' as a default method as in 
\begin{lstlisting}
@Mixin interface Box{ default int val(){return 0;} }
\end{lstlisting}
if setters are required, a possible extension of our code expansion could recognize a field if the getter is provided and the setter is required, and could generate the following code:
\begin{lstlisting}
interface Box{ 
  default int val(){return 0;} //provided
  void val(int _val);//provided
  static Box of(){return new Box(){//generated
    int val=Box.super.val();
    int val(){return val;}
    void val(int _val){val=_val;}
    };}}
\end{lstlisting}
We are unsure of the value of this solution: is very tricky, the user define a method that (contrary to our usual expectation) is actually overridden in a way that the behaviour change, but change only after the first setter is called, plus this code would cache the result instead of re-computing it every time. This can be very relevant and tricky in a non functional setting.

\subsection{Class invariants in ClassLess Java}
Since the objects are created by automatically generated methods,
another limitation of our current approach is that there is no place where the user can dynamically check for class invariants.
In Java often we see code like
\begin{lstlisting}
class Point{ int x; int y;
  Point(int x; int y){this.x=x;this.y=y; assert this.checkInvariant();}
  private boolean checkInvariant(){... x>0,y>0...}
\end{lstlisting} 

We are considering an extension of our annotation where 
default methods with the special name \Q@checkInvariant()@ will be called inside of the \Q@of@ methods.
if multiple interfaces are implemented, and more then one offers
\Q@checkInvariant()@,  a composed implementation could be automatically generated, composing by \Q@&&@ the various competing implementations.

\subsection{Clone, toString, equals and hashCode}
Methods originally defined in \Q@Object@, as \Q@clone@ and \Q@toString@ can be supported by our approach, but they need special care. If an interface annotated with \mixin ask an implementation for \Q@clone@, \Q@toString@, \Q@equals@ or \Q@hashCode@ we can easily generate one from the fields.\footnote{In particular, for clone we can do automatic return type refinement as we do for \Q@with-@ and fluent setters. Note how this would solve most of the Java ugliness related to \Q@clone@ methods.}

However, if the user wish to provide its own implementation, since the method is also implemented in \Q@Object@ we would have a conflict, that we have to explicitly resolve inside of \Q@of@, by implementing the method and delegating it to the user implementation, thus

\begin{lstlisting}
@Mixin interface Point{ int x(); int y();
  default Point clone(){ return Point.of(0,0);}//user defined clone
  }
\end{lstlisting} 
Would expand into 

\begin{lstlisting}
interface Point{ int x(); int y();
  default Point clone(){ return Point.of(0,0);}//user defined clone
  public static Point of(int _x,int_y){
    return new Point(){...
      public Point clone(){ return Point.super.clone();}
      };  }  }
\end{lstlisting} 

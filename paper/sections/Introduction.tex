\section{Introduction}\label{sec:intro}

Java 8 introduced \emph{default methods}, allowing interfaces to have
method implementations. The main motivation behind the introduction of
default methods in Java 8 is \emph{interface evolution}. That is, to
allow interfaces to be extended over time, while preserving backwards
compatibility. It soon became clear that default methods could also be
used to emulate something similar to \emph{traits}~\cite{}. The
original notion of traits by Scharli et al. prescribes, among other
things, that: 1) a trait provides a set of methods that implement
behaviour; and 2) a trait does not specify any state variables, so the
methods provided by traits do not access state variables
directly. Java 8 interfaces follow similar principles too. Indeed, a
detailed description of how to emulate trait-oriented programming in
Java 8 can be found in the work by Bono et al.~\cite{}.  The Java 8
team designing default methods, was also fully aware of that secondary
use of interfaces, but it was not their objective to model traits:
``The key goal of adding default methods to Java was "interface
evolution", not "poor man's traits"''~\cite{mailing list}. As a result
they were happy to support the secondary use of interfaces with
default methods as long as it did not make the implementation and
language more complex.
 
Still, the design has been criticised for being too conservative and 
not very useful in its current form to model traits or multiple 
inheritance~\cite{}. 
Indeed, our own personal experience of combining default methods 
and multiple interface inheritance in Java to achieve multiple implementation 
inheritance is that many workarounds and boilerplate code are needed. 
In particular, we encountered difficulties because:

\begin{itemize}

\item {\em Interfaces have no constructors.} As a result classes are 
still required to create objects, leading to substantial boilerplate 
code for initialization.

\item {\em Interfaces do not have state.} This creates a tension between 
 using multiple inheritance and having state. Using setter and
  getter methods is a way out of this tension, but this workaround
  requires tedious boilerplate classes that latter implements those
  methods.

\item {\em Useful, general purpose methods, require special care in
  the presence of subtyping.} Methods such as $clone$, or
  \emph{fluent} setters~\cite{}, not only require access to the
  internal state of an object, but they also require their types to be
  refined in subtypes.

\end{itemize}

\noindent Clearly, a way around those difficulties would be to try to
change the language and just remove these limitations. Scala's own
notion of traits, for example, allows state in traits. Ofcourse adding
state (and other features) to interfaces would complicate the language
and require changes in the compiler, and this would go beyond the
goals of Java 8 development team.

This paper takes a different approach. Rather than trying to get
around the difficulties by changing the language in fundamental ways,
we show that, with some minor syntactic sugar, default methods and
interface inheritance are in fact be very expressive. Our proposed
syntax sugar enables powerful object-oriented idioms, using multiple
inheritance, to be expressed directly without modifications to the
current Java language. We call our sugar \emph{object interfaces},
because such interfaces can be instantiated directly, without the need
for an explict class definition. Object interfaces come with their own
object instantiation mechanism, providing an alternative to class
constructors. Moreover, object interfaces avoid some syntactic
boilerplate caused by Java being originally designed to work mainly
with classes. This includes support for various common utility methods
(such as getters and setters, or clone methods), even in the presence
of subtyping. As a result, with object interfaces, many Java programs
can be built without using a single class!  \bruno{integrate more of
  Marco's text.}

To formalize object interfaces, we propose Featherweight Object Interfaces (FOI): 
a FeatherweightJava-style calculus, which captures the essence 
of interfaces with default methods. The semantics of object interfaces 
is given as a type-directed translation from FOI to itself. 
In the resulting FOI code all object interfaces are translated into 
regular FOI (and Java) interfaces with default methods. The translation 
is proved to be type-preserving, ensuring that the translation does 
not introduce type-errors. One interesting aspect of the theorem is that, 
if we ignore the object annotations, the program still type-checks 
under the regular typing rules of FOI (and Java).\bruno{double-check!}

We also present a prototype implementation of object interfaces using
Java annotations. One benefit of an annotation-based implementation 
is that existing Java tools (such as IDE's) work with out-of-the-box
with our implementation. As a result we could experiment object
interfaces with several interesting Java programs, and conduct various
case studies. \bruno{mention the following or not? maybe good if we
  had something about tuning.} Ofcourse, another implementation option would be to
extend Java, with a single qualifier keyword {\bf object}, so that
object interfaces would be an intrinsic part of the language. We leave
this for future work. 

To evaluate the usefulness of object interfaces, we illustrate 3
applications and case studies. The first application is a simple 
solution to the Expression Problem~\cite{}, supporting independent 
extensibility~\cite{}, and without boilerplate code. The second
application is to show how embedded DSLs using fluent interfaces~\cite{} 
can be easily defined using object interfaces. Finally, the last
application is a larger case study for a simple Maze game implemented with 
multiple inheritance. For the last application we show that there is a
significant reduction in the numbers of lines of code when compared 
to an existing implementation~\cite{} using plain Java 8. 
Noteworthy, is the fact that all applications are implemented 
without defining a single class.

In summary, the contributions of this paper are:

\begin{itemize}

\item {\bf Object interfaces:} A simple language feature that allows 
various powerful programming idioms to be expressed conveniently in
Java. Object interfaces are pure sugar: they can be desugared into standard Java 
code, without loss of modularity or type-safety. 

\item {\bf Featherweight Object (FC):} A simple formal calculus that models 
the essential features of Java 8 interfaces with default methods, and 
can be used to formally define the desugaring of object interfaces. 
We prove ...

\item {\bf Implementation and Case Studies:} We have a prototype implementation 
  of object interfaces, using Java annotations. Moreover the usefulness
  of object interfaces is illustrated through various examples and
  case studies.

\end{itemize}


\bruno{Useful reference, perhaps, on the discussion of why not override object 
methods: 
\url{http://mail.openjdk.java.net/pipermail/lambda-dev/2013-March/008435.html}}

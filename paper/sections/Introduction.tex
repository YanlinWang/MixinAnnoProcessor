\section{Introduction}\label{sec:intro}

Java 8 introduced \emph{default methods}, allowing interfaces to have
method implementations. The main motivation behind the introduction of
default methods in Java 8 is \emph{interface evolution}. That is, to
allow interfaces to be extended over time, while preserving backwards
compatibility. It soon became clear that default methods could also be
used to emulate something similar to \emph{traits}~\cite{}. The
original notion of traits by Scharli et al. prescribes, among other
things, that: 1) a trait provides a set of methods that implement
behaviour; and 2) a trait does not specify any state variables, so the
methods provided by traits do not access state variables
directly. Java 8 interfaces follow similar principles too. Indeed, a
detailed description of how to emulate trait-oriented programming in
Java 8 can be found in the work by Bono et al.~\cite{}.  The Java 8
team designing default methods, was also fully aware of that secondary
use of interfaces, but it was not their objective to model traits:
``The key goal of adding default methods to Java was "interface
evolution", not "poor man's traits"''~\cite{mailing list}. As a result
they were happy to support the secondary use of interfaces with
default methods as long as it did not make the implementation and
language more complex.
 
Still, the design has been criticised for being too conservative and 
not very useful in its current form to model traits or multiple 
inheritance~\cite{}. 
Indeed, our own personal experience of combining default methods 
and multiple interface inheritance in Java to achieve multiple implementation 
inheritance is that many workarounds and boilerplate code are needed. 
In particular, we encountered difficulties because:

\begin{itemize}

\item {\em Interfaces have no constructors.} As a result classes are 
still required to create objects, leading to substantial boilerplate 
code for initialization.

\item {\em Interfaces do not have state.} This creates a tension between 
 using multiple inheritance and having state. Using setter and
  getter methods is a way out of this tension, but this workaround
  requires tedious boilerplate classes that latter implements those
  methods.

\item {\em Useful, general purpose methods, require special care in
  the presence of subtyping.} Methods such as $clone$, or
  \emph{fluent} setters~\cite{}, not only require access to the
  internal state of an object, but they also require their types to be
  refined in subtypes.

\end{itemize}

\noindent Clearly, a way around those difficulties would be to try to
change the language and just remove these limitations. Scala's own
notion of traits, for example, allows state in traits. Of course adding
state (and other features) to interfaces would complicate the language
and require changes in the compiler, and this would go beyond the
goals of Java 8 development team.

This paper takes a different approach. Rather than trying to get
around the difficulties by changing the language in fundamental ways,
we show that, with some minor syntactic sugar, default methods and
interface inheritance are in fact be very expressive. Our proposed
syntax sugar enables powerful object-oriented idioms, using multiple
inheritance, to be expressed directly without modifications to the
current Java language. We call our sugar \emph{object interfaces},
because such interfaces can be instantiated directly, without the need
for an explict class definition. Object interfaces come with their own
object instantiation mechanism, providing an alternative to class
constructors. Moreover, object interfaces avoid some syntactic
boilerplate caused by Java being originally designed to work mainly
with classes. This includes support for various common utility methods
(such as getters and setters, or clone methods), even in the presence
of subtyping. As a result, with object interfaces, many Java programs
can be built without using a single class!  \bruno{integrate more of
  Marco's text.}

To formalize object interfaces, we propose Classless Java (CJ)\marco{I propose to call it directly ClassLess Java, the  Featherweight part is in being classless.}: 
a FeatherweightJava-style calculus, which captures the essence 
of interfaces with default methods. The semantics of object interfaces 
is given as a type-directed translation from CJ to itself. 
In the resulting CJ code all object interfaces are translated into 
regular CJ (and Java) interfaces with default methods. The translation 
is proved to be type-preserving, ensuring that the translation does 
not introduce type-errors. One interesting aspect of the theorem is that, 
if we ignore the object annotations, the program still type-checks 
under the regular typing rules of CJ (and Java).\bruno{double-check!}
\marco{ I do not understand what you mean. 1) annotations are part of java and CJ, so you do not need to remove them 2) programs well typed without expansion are well typed with expansion, here you seams to state the opposite}
CJ's usefulness goes beyond serving as a calculus to formalize object
interfaces. During the development process of CJ, we encountered an 
incoherent behaviour in Java's implementation of default methods that 
could be classified as a bug. \bruno{Should we report bug to the Java
  developers mailing list?}
\marco{we need to put the exact javac version}
We also present a prototype implementation of object interfaces using
Java annotations. One benefit of an annotation-based implementation 
is that existing Java tools (such as IDE's) work with out-of-the-box
with our implementation. As a result we could experiment object
interfaces with several interesting Java programs, and conduct various
case studies. 
\marco{ I removed your text here and I add after to try talking about tuning}
%I think that the qualifier object goes AGAINST the idea of tuning.
%\bruno{mention the following or not? maybe good if we
%  had something about tuning.} Of course, another implementation option would be to
%extend Java, with a single qualifier keyword {\bf object}, so that
%object interfaces would be an intrinsic part of the language. We leave
%this for future work. 


To evaluate the usefulness of object interfaces, we illustrate 3
applications and case studies. The first application is a simple 
solution to the Expression Problem~\cite{}, supporting independent 
extensibility~\cite{}, and without boilerplate code. The second
application is to show how embedded DSLs using fluent interfaces~\cite{} 
can be easily defined using object interfaces. Finally, the last
application is a larger case study for a simple Maze game implemented with 
multiple inheritance. For the last application we show that there is a
significant reduction in the numbers of lines of code when compared 
to an existing implementation~\cite{} using plain Java 8. 
Noteworthy, is the fact that all applications are implemented 
without defining a single class.

Moreover, we believe that our approach is an example of a more general idea, that we call \emph{Language Tuning},
a concept that sits in the middle between a lightweight language extension and a glorified library.
Thanks to Java dynamic class loading and annotation processing,  annotations can trigger type-driven transformations on classes during either loading or compilation.
There are many examples of such Language Tuning libraries,~\cite[lomboc,anotherImSearching].
Language tuning can offers many features usually implemented by a real language extension, but they do not modify the syntax; pre-existing tools can work transparently on the tuned language.

In summary, the contributions of this paper are:

\begin{itemize}

\item {\bf Object Interfaces:} A simple feature that allows 
various powerful programming idioms to be expressed conveniently in
Java. Object interfaces are pure sugar: they are desugared into standard Java 
code, without loss of modularity or type-safety. 

\item {\bf ClassLess Java (CJ):} A simple formal calculus that models 
the essential features of Java 8 interfaces with default methods, and 
can be used to formally define the desugaring of object interfaces. 
We prove ...

\item {\bf A Bug in the Implementation of Java 8:}\bruno{state this as
  a contrib?}\marco{yes, especially if we "suggest solutions"}

\item {\bf Implementation and Case Studies:} We have a prototype implementation 
  of object interfaces, using Java annotations. Moreover the usefulness
  of object interfaces is illustrated through various examples and
  case studies.

\item{\bf Language Tuning} We identify this concept and we describe Project Lomboc and object interfaces as examples of Language Tuning.
\end{itemize}


\bruno{Useful reference, perhaps, on the discussion of why not override object 
methods: 
\url{http://mail.openjdk.java.net/pipermail/lambda-dev/2013-March/008435.html}}
\bruno{Maybe Marco's text can be in the conclusion, which I think is
  ok to be more provocative. I tried to be a bit more contained in the
Introduction.}
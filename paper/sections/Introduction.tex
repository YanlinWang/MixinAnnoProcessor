\section{Introduction}\label{sec:intro}

Java 8 introduced \emph{default methods}, allowing interfaces to have
method implementations. The main motivation behind the introduction of
default methods in Java 8 is \emph{interface evolution}. That is, to
allow interfaces to be extended over time, while preserving backwards
compatibility. It soon became clear that default methods could also be
used to emulate something similar to \emph{traits}~\cite{}. The
original notion of traits by Scharli et al. prescribes, among other
things, that: 1) a trait provides a set of methods that implement
behaviour; and 2) a trait does not specify any state variables, so the
methods provided by traits do not access state variables directly.  A
detailed description of how to emulate trait-oriented programming in
Java 8 can be found in the work by Bono et al.~\cite{}.  The Java 8
team designing default interfaces, was also fully aware of that
secondary use of traits, but it was not their objective to model
traits: ``The key goal of adding default methods to Java was
"interface evolution", not "poor man's traits"''~\cite{mailing list}. As
a result they were happy to support the secondary use of default
methods as long as it did not make the implementation and language
more complex. 
 
Still, the design has been criticised for being too conservative and 
not very useful in its current form to model traits or multiple 
inheritance~\cite{}. \bruno{mention scala traits here?}
Indeed, our own personal experience of combining default methods 
and multiple interface inheritance to achieve multiple implementation 
inheritance is that many workarounds and boilerplate code are needed. 
In particular, we encountered difficulties because:

\begin{itemize}

\item {\em Interfaces have no constructors.} As a result classes are 
still required to create objects, leading to substantial boilerplate 
code for initialization.

\item {\em Interfaces do not have state.} This creates a tension between 
 using multiple inheritance and having state. Using setter and
  getter methods is a way out of this tension, but this workaround
  requires tedious boilerplate classes that latter implements those
  methods.

\item {\em Useful, general purpose methods, require special care in
  the presence of subtyping.} Methods such as $clone$, or
  \emph{fluent} setters~\cite{}, not only require access to the
  internal state of an object, but they also require their types to be
  refined in subtypes.

\end{itemize}

\noindent Clearly, a way around those difficulties would be to try 
to change the language and just remove these limitations. Scala's 
own notion of traits, for example, allows state in traits. Ofcourse 
this would complicate the language and require changes in the compiler, 
and this would go beyond the goals of Java 8 development team. 

This paper takes a different approach. Rather than trying to get
around the diffulculties by extending the language in quite
fundamental ways, we show that, with some minor syntactic sugar,
default methods and interface inheritance are in fact be very
expressive. Our proposed syntax sugar, called \emph{concrete
  interfaces}, enables powerful object-oriented idioms, using multiple
inheritance, to be expressed directly in the current Java
language. Concrete interfaces avoid some syntactic boilerplate caused
by Java being originally designed to work mainly with
classes. Moreover, concrete interfaces come with their own object
instantiation mechanism, providing an alternative to class
constructors. Finally concrete interfaces support various common
utility methods (such as getters and setters, or clone methods)
without boilerplate; and they automatically they with utility methods
in the presence of subtyping. As a result many Java programs can be 
built without using a single class! \bruno{integrate more of Marco's text.}

To formalize concrete interfaces, we propose FeatherweightConcrete (FC): 
a FeatherweightJava-style calculus, which captures the essence 
of interfaces with default methods. The semantics of concrete interfaces 
is given as a type-directed translation from FC to FC itself. 
In the resulting FC code all concrete interfaces are translated into 
regular FC (and Java) interfaces with default methods. The translation 
is proved to be type-preserving, ensuring that the tranlation does 
not introduce new errors. One interesting aspect of the theorem is that 
if we ignore the concrete annotations, the program still type-checks 
under the regular typing rules of FC.\bruno{double-check!}

An implementation of concrete interfaces using Java annotations and a
formalization of the static and dynamic semantics are presented. We
implement concrete interfaces, purely using Java annotations. As such
no new syntax is required, and existing Java tools (such as IDE's)
work with our implementation.

Moreover the usefulness of concrete
interfaces is illustrated through various examples and case studies.

The contributions of this paper are:

\begin{itemize}

\item {\bf Concrete interfaces:} A simple language feature that allows 
various powerful programming idioms in Java 8 to be expressed conveniently. 
Concrete interfaces are pure sugar: they can be desugared into standard Java 
code, without loss of modularity or type-safety. 

\item {\bf Featherweight Concrete (FC):} A simple formal calculus that models 
the essential features of Java 8 interfaces with default methods, and 
can be used to formally define the desugaring of concrete interfaces. 
We prove ...

\item {\bf Implementation and Case Studies:} We have a prototype implementation 
  of concrete interfaces, using Java annotations. Moreover the usefulness
  of concrete interfaces is illustrated through various examples and
  case studies.

\end{itemize}

\bruno{Useful reference, perhaps, on the discussion of why not override object 
methods: 
\url{http://mail.openjdk.java.net/pipermail/lambda-dev/2013-March/008435.html}}

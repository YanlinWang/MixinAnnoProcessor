\section{Comparing to traits and mixins}

\begin{comment}
Haoyuan

   - vs both: we do automatic return type refinement, which has useful applications
   (example: Expression Problem)

   - vs traits: we support of methods to create new objects (a replacement to constructors);
   Moreover we have the with and clone methods (we miss more applications for those). Show
   how to model the operations on traits; discuss operations that we cannot model
   (example: renaming).

   - vs mixins: we use the trait model of explicitly resolving conflicts. This is arguably
   better for reasoning.
\end{comment}

Our approach is based on code generation by Java annotations. The model we generate encourages composability and reusability in object-oriented programming, and is considered to be an alternative to traits or mixins,  meanwhile achieving better performance in some situations. Hence it is necessary for us to make a comparison between this approach and traits (or mixins) we commonly used before.

Our approach is quite different from mixins, in the sense that we use the trait model of explicitly resolving conflicts. Just as [Scharli2003] demonstrated in the paper, mixin inheritance is a good approach of achieving code reuse, nevertheless, the mixin model is not so expressive to resolve conflicts from many mixins. In the trait model, aliases and exclusions are provided for explicit conflict resolution. Such operations can actually be modelled in the mechanism of our approach.

Here we present how the original operations on traits are supported by our model.
\begin{itemize}
\item \textbf{Symmetric sum}: the symmetric composition of two disjoint traits is achieved by simply implementing two interfaces in Java correspondingly, without overriding any method. The composition relies on multiple inheritance on interfaces, which is supported by Java.
\item \textbf{Override}: the overriding operation (also known as asymmetric sum) is modelled by implementing many interfaces, while overriding some methods inside. The code below gives an example of explicitly specifying which super interface to refer to, regarding two methods with the same name.
    \begin{lstlisting}
    interface A { default int m() {return 1;} }
    interface B { default int m() {return 2;} }
    interface C extends A, B { default int m() {return B.super.m();} } 
    \end{lstlisting}
    Here the method \texttt{m()} in interface \texttt{C} simply inherits from \texttt{B.m()}.
\item \textbf{Alias}: an alias operation adds a new name to an old method when creating the new trait. In Java, we just create a new method with reference to the existing method in its super interface. See the example below, where the new method \texttt{k()} is an alias of the existing method \texttt{m()}.
    \begin{lstlisting}
    interface A { default int m() {return 1;} }
    interface B extends A { default int k() {return A.super.m();} }
    \end{lstlisting}
\item \textbf{Exclusion}: exclusion is also supported in Java, where method declarations can hide the default methods correspondingly in the super interfaces. See the example below.
    \begin{lstlisting}
    interface A { default int m() {return 1;} }
    interface B extends A { int m(); }
    \end{lstlisting}
\end{itemize}

Besides, we support \texttt{of} methods in our model, as a replacement to the constructors in original traits. Furthermore, we also support \texttt{with} and \texttt{clone} methods as auxiliary constructors, making the creation of instances more flexible and convenient. Conversely, there are certain operations we cannot model, such as method renaming (as in [Reppy2006]), which breaks structural subtyping.

A further feature leads to return type refinement in our model. Generally speaking, when we use inheritance to create a new trait, with the return type of an existing method being refined, the new \texttt{of} method keeps this consistency. This feature is very useful in many applications; we will see how it makes a difference in our Expression Problem example, in Section [Case Study]. 
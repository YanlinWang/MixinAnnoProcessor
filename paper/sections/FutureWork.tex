\section{Future work}\label{sec:futurework}

\subsection{Qualifiers in Methods} %{Private state}
\yanlin{briefly mentioned ``synchronized'' keyword, didn't put the workaround
  here, it's in the code.}
The biggest limitation of our approach is the inability to model qualifiers
for class methods (private, protected, synchronized, etc.). For example, the absence
of the support for private/protected methods in Java8 interfaces forces all
members of interfaces to be public, including static methods. Since we use
abstract methods to encode the state, our state is always all public. Still, because 
the state can only be accessed by methods, it 
is impossible for the user to know if a certain method maps directly to a field
or if it has a default implementation.  If the user wants a constructor that
does not directly maps to the fields, (as for secondary constructors in Scala)
he can simply define its own \Q@of@ method and delegate on the generated one, as
in
\begin{lstlisting}
@Mixin interface Point{
  int x(); int y();
  static Point of(int val){return Point.of(val,val);}  
}
\end{lstlisting}
However, the generated \Q@of@ method would also be present and public.  If a
future version of Java was to support \emph{static private methods in
  interfaces} we could extend our code generation to handle also encapsulation.
Currently, it is possible to use a public nested class with private static
methods inside, but this is ugly and cumbersome. One possibility is that the
annotation processor takes code with a \Q!@Private! annotation, and turns it into
static private methods of a nested class. In this extension, also the \Q@of@
method could be made private following the same pattern.

\subsection{State initialization}
As discussed before, the user can trivially define its own \Q@of@ method, and
initialize a portion of the state with default values.  However, the
initialization code would not be reusable, and subinterfaces would have
to repeat such initialization code.  If a field has no setters, a simple
alternative is to just define the ``field'' as a default method as in
\begin{lstlisting}
@Mixin interface Box{ default int val(){return 0;} }
\end{lstlisting}
If setters are required, a possible extension of our code expansion could
recognize a field if the getter is provided and the setter is required, and
could generate the following code: \yanlin{both of the two generated val()
  method should be public to pass compilation. Did you omit the public keyword
  on purpose to make the code clean? }
\begin{lstlisting}
interface Box{ 
  default int val(){return 0;} //provided
  void val(int _val);//provided
  static Box of(){return new Box(){//generated
    int val=Box.super.val();
    int val(){return val;}
    void val(int _val){val=_val;}
    };}}
\end{lstlisting}
We are unsure of the value of this solution: is very tricky, the user define a
method that (contrary to our usual expectation) is actually overridden in a way
that the behaviour changes, but change only after the first setter is called,
plus this code would cache the result instead of re-computing it every
time. This can be very relevant and tricky in a non functional setting.
\bruno{Yanlin please polish text/break long sentences.}

\begin{comment}
\subsection{Class Invariants in ClassLess Java}
Since objects are created by automatically generated methods, another limitation
of our current approach is that there is no place where the user can dynamically
check for class invariants. In Java often we see code like
\begin{lstlisting}
class Point{ int x; int y;
  Point(int x; int y){this.x=x;this.y=y; assert this.checkInvariant();}
  private boolean checkInvariant(){... x>0,y>0...}
}
\end{lstlisting} 

We are considering an extension of our annotation where 
default methods with the special name \Q@checkInvariant()@ will be called inside the \Q@of@ methods.
If multiple interfaces are implemented, and more then one offers
\Q@checkInvariant()@,  a composed implementation could be automatically generated, composing by \Q@&&@ the various competing implementations.
\end{comment}
\bruno{removed the invariants stuff; we need space, I think.}

\subsection{Clone, toString, equals and hashCode}

Methods originally defined in Java class \Q@Object@, as \Q@clone@ and
\Q@toString@, can be supported by our approach, but they need special
care. If an interface annotated with \mixin asks an implementation for
\Q@clone@, \Q@toString@, \Q@equals@ or \Q@hashCode@ we can easily
generate one from the fields.\footnote{In particular, for clone we can
  do automatic return type refinement as we do for \Q@with-@ and
  fluent setters. Note how this would solve most of the Java ugliness
  related to \Q@clone@ methods.}
However, if the user wishes to provide his own implementation, since the method is
also implemented in \Q@Object@, a conflict arises. The user has to
explicitly resolve the conflict inside \Q@of@, by implementing the method and
delegating it to the user implementation, thus
\begin{lstlisting}
@Mixin interface Point{ int x(); int y();
  default Point clone(){ return Point.of(0,0);}//user defined clone
}
\end{lstlisting} 
Would expand into 

\begin{lstlisting}
interface Point{ int x(); int y();
  default Point clone(){ return Point.of(0,0);}//user defined clone
  public static Point of(int _x,int_y){
    return new Point(){...
      public Point clone(){ return Point.super.clone();}
      };  }  }
\end{lstlisting} 

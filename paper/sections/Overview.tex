\section{Overview}\label{sec:ep}
The single inheritance support for classes in Java prohibits doing multiple
inheritance in Java. Instead, the support of multiple inheritance support for
interfaces makes us to think the possibility of using interfaces only, throwing
away classes. But immediately we will face the following three problems of using
interfaces in Java.

\subsection{Problems with Java Interfaces}\label{sec:intf_prob}
\paragraph{Instantiation Code}. If we use interfaces, then we cannot
avoid instantiation code. 
\begin{lstlisting}
interface P {
    default m() { ... }
}
\end{lstlisting}
For example, even if interface \texttt{P} is complete (does not contain any
un-implemented method), to instantiate it programmers still need to create a
class \texttt{PImpl} that has a constructor for instantiation:
\begin{lstlisting}
class PImpl extends P {}
\end{lstlisting}

\paragraph{Prohibition of Field Members Inside Interfaces}
Only methods (abstract, static or default) are allowed to appear in the
definition of interfaces. The use of interfaces prohibits defining field members
inside. This limitation of interfaces hinders the adoption of using interfaces
only. Because the need of using field members almost \emph{always} exists. Hence
it forces programmers to use classes, but this gives up the ability of multiple
inheritance in Java. So the trade-off is: if you use interfaces, then no field
members; if you use classes, then no multiple inheritance.

\paragraph{Manual Type Refinement}
We will introduce operations \texttt{with} and \texttt{clone}, which requires
return type refinement in extensions. A \texttt{clone} method
returns a copy of the current object. For example, interfaces \texttt{I} and its
extension \texttt{I2}:
\begin{lstlisting}
interface I { I clone(); }
interface I2 extends I { 
  // inherit I clone() from super-interface I
  // which should be refined to I2 clone();
  I2 clone();
}
\end{lstlisting}
 
Interface \texttt{I} contains a \texttt{clone()} method which returns a copy of
current object (of type \texttt{I}). Interface \texttt{I2} is an extension of
interface \texttt{I}, so inheriting the \texttt{clone()} method from
\texttt{I}. Since the current interface is \texttt{I2}, now the return type of
\texttt{clone()} \texttt{should} be refined to \texttt{I2}. However, interfaces
in Java does not provide this kind of automatic refinement. In order to achieve
the same effect, programmers have to manually override it by a new
\texttt{clone()} method with return type \texttt{I2}.


\subsection{A Running Example: \texttt{Point}}
Suppose we want to create a point component that models the a point in space,
that has x-coordinate and y-coordinate. For example, if we create the
\texttt{Point} interface in Java, it would look like this:

\begin{lstlisting}
interface Point {
    int x();
    int y(); 
}
\end{lstlisting}

\texttt{Point} has two (conceptually) member fields \texttt{x} and \texttt{y},
representing the two coordinates of a point. Methods \texttt{int x()} and
\texttt{int y()} serve as \emph{getter} methods. 
% Methods \texttt{void X(int X)} and \texttt{void Y(int Y)} serve as
% \emph{setter} methods. Method \texttt{Point withX(int X)} updates field
% \texttt{X} and returns \textbf{this}.

\subsection{Naive Implementation}
In Java, to implement an interface like \texttt{Point}, a typical and trivial
approach that programmers usually do is creating a class extending the interface
and providing implementation for all methods inside. For example, this is the
implementation for interface \texttt{Point}:

\lstinputlisting[linerange=33-46]{../UseMixinLombok/src/overview/TestPoint.java} % APPLY:linerange=POINTIMPL

\texttt{PointImpl} implements \texttt{Point} and provides a constructor with
quite mechanical code. What's worse, the implementation in \texttt{PointImpl}
may not be reused in a single inheritance language.

\subsection{Our Approach}
Instead of writing a whole another class to provide the implementation for
\texttt{Point}, we annotate on interface \texttt{Point} directly with \mixin:

\lstinputlisting[linerange=6-10]{../UseMixinLombok/src/overview/TestPoint.java} % APPLY:linerange=POINT

The \mixin annotation will generate a static method \texttt{of} inside
\texttt{Point}. The method \texttt{of} mimic the functionality of constructors,
it takes arguments same as constructors and return objects similar to
constructors. It makes use of Java anonymous classes and achieves the same
implementation as \texttt{PointImpl}. 

With our approach, we provide a Java annotation \mixin to provide default
implementations for various methods and a mechanism to instantiate
objects. \mixin annotation helps programmers to write less cumbersome code and
instantiate interfaces in Java. 

\lstinputlisting[linerange=15-27]{../UseMixinLombok/src/overview/TestPoint.java} % APPLY:linerange=POINT_OF

\subsection{What  \mixin Generates}
Apart from generating code for \emph{getter} methods, the annotation processor
can also generate \emph{setter} methods, \emph{with} methods, \texttt{clone}
methods, etc. We summarize all the forms of method \mixin  supports below. Inside
the anonymous class in the annotated interface, the following code are
generated:

\begin{itemize}
\item For methods inside the interface with the form \texttt{Tx x()}:
  \begin{itemize}
   \item \texttt{x} is the getter method, with return type
     \texttt{Tx}. Conceptually, it is a member field with name \texttt{x} and
     type \texttt{Tx}.
   \item generate member field \texttt{\_x} of type \texttt{Tx}, initialized
     with \texttt{x}.
   \item generate implemented getter method:
       \begin{lstlisting}
           public Tx x() { return _x; }
       \end{lstlisting}
   \end{itemize}

\item For methods inside the interface with the form \texttt{void x(Tx x)}:
  \begin{itemize}
    \item check if exist method \texttt{Tx x()}. If not, generate error.
    \item generate implemented setter method:
       \begin{lstlisting}
           public void x(Tx x) { this.x = x; }
       \end{lstlisting}
    \end{itemize}

\item For methods with the form \texttt{T withX(Tx \_)}:
  \begin{itemize}
  \item if there is no \texttt{x} field, or type \texttt{Tx} does not match,
    then generate error.
  \item implement `withX` using the `of` method.
  \end{itemize}

\item For methods with the form of \texttt{T clone()}: Use \texttt{of} method as
  the constructor, to create a new object with the same field values as the
  current one.

\item For methods with the form of \texttt{T x(Tx \_)}:
  \begin{itemize}
    \item check if exist method \texttt{T x()}, if not, generate error.
    \item inside the inner class, generate
      \begin{lstlisting}
          public T x(Tx x) { this.x = x; return this;}
      \end{lstlisting}
  \end{itemize}
\end{itemize}

\subsection{More On \mixin}
Besides the benefit of freeing programmers from writing boilerplate code, our
\mixin annotation can also allow programs to mimic multiple inheritance in a
restricted form easily.

\lstinputlisting[linerange=46-52]{../UseMixinLombok/src/test/TestAnimal.java}% APPLY:linerange=POINT2D

\lstinputlisting[linerange=56-60]{../UseMixinLombok/src/test/TestAnimal.java}% APPLY:linerange=POINT3D

\lstinputlisting[linerange=64-67]{../UseMixinLombok/src/test/TestAnimal.java}% APPLY:linerange=ANIMAL

\lstinputlisting[linerange=71-76]{../UseMixinLombok/src/test/TestAnimal.java}% APPLY:linerange=HORSE

\lstinputlisting[linerange=80-92]{../UseMixinLombok/src/test/TestAnimal.java}% APPLY:linerange=BIRD

\lstinputlisting[linerange=96-97]{../UseMixinLombok/src/test/TestAnimal.java}% APPLY:linerange=PEGASUS

Interface \texttt{Point3D} extends \texttt{Point/Point2D} with a new abstract
method \texttt{int z()} (treated as a getter for member field
\texttt{z}). Interface \texttt{Horse} shows the usage and advantage of
\emph{with} methods by method \texttt{run()}: method \texttt{withX} returns a
new point object with field \texttt{x} updated by the argument to
\texttt{withX}. Without these \texttt{with} methods, operations like
\texttt{run()} would be much harder to define. Note that the return type of
various methods get refined automatically by our annotation processor. Besides
\emph{with}, other methods (including \emph{clone}, \emph{of}) also do
type-refinements automatically.

The \emph{``multiple inheritance''} case appears at interface
\texttt{Pegasus}. Pegasuses can not only \emph{run} but also \emph{fly}!
Interface \texttt{Pegasus} obtains \texttt{fly} and \texttt{run} functionality
through interface \texttt{Horse} and \texttt{Bird}. Using \mixin annotation,
actually these is no code at all programmers have to write. The idea of using
default methods inside interfaces was proposed in ~\cite{}. It enables us to do
multiple inheritance, which otherwise is hard to do in Java-like languages that
do not support multiple inheritance, easily.

In summary, our approach solves the three problems of interfaces
(Section~\ref{sec:intf_prob}):
\begin{itemize}
\item Instantiation Code: Our approach solves the instantiation problem by
  providing \texttt{of} methods, mimicking the behavior of constructors.
\item No Fields Inside Interfaces: In our approach, abstract methods without
  arguments stands for fields. The return type of the methods are the types of
  member fields. Getters and setters are also generated automatically.
\item Manual Type Refinement: The annotation processor is designed to do this
  type refinement automatically, for \texttt{with-} methods, \texttt{clone}
  methods, etc.
\end{itemize}

\section{Overview}\label{sec:ep}
Yanlin

* Explain what the Mixin annotations do using examples.

* Motivate the use of multiple inheritance in Java.

* Maybe use Marco's example (Point example).

We provide a Java annotation \mixin to provide default implementations for
various methods and a mechanism to instantiate objects. \mixin annotation helps
programmers to write less cumbersome code and instantiate interfaces in
Java. More over, with \mixin annotation, programmers can mimic multiple
inheritance in a restricted form easily.

For example, interface \texttt{Point} annotated with \mixin:

\lstinputlisting[linerange=6-10]{../UseMixinLombok/src/overview/TestPoint.java} % APPLY:linerange=POINT

\texttt{Point} has two (conceptually) member fields \texttt{X} and
\texttt{Y}. Methods \texttt{int X()} and \texttt{int Y()} serve as \emph{getter}
methods. % Methods \texttt{void X(int X)} and \texttt{void Y(int Y)} serve as
% \emph{setter} methods. Method \texttt{Point withX(int X)} updates field
% \texttt{X} and returns \textbf{this}.

A typical and trivial implementation that programmers usually do is:

\lstinputlisting[linerange=33-46]{../UseMixinLombok/src/overview/TestPoint.java} % APPLY:linerange=POINTIMPL

\texttt{PointImpl} implements \texttt{Point} and provides a constructor with
quite mechanical code. What's worse, the implementation in \texttt{PointImpl}
may not be reused in a single inheritance language. However, with our approach,
the \mixin annotation will generate a static method \texttt{of} inside
\texttt{Point}. \texttt{of} makes use of Java anonymous classes and achieves the
same implementation as \texttt{PointImpl}.

\lstinputlisting[linerange=15-27]{../UseMixinLombok/src/overview/TestPoint.java} % APPLY:linerange=POINT_OF

Apart from generating code for \emph{getter} methods, the annotation processor
can also generate \emph{setter} methods, \emph{with} methods, \texttt{clone}
methods, etc. We summarize all the forms of method \mixin  supports below. Inside
the anonymous class in the annotated interface, the following code are
generated:

\begin{itemize}
\item For methods inside the interface with the form \texttt{Tx x()}:
  \begin{itemize}
   \item \texttt{x} is the getter method, with return type
     \texttt{Tx}. Conceptually, it is a member field with name \texttt{x} and
     type \texttt{Tx}.
   \item generate member field \texttt{\_x} of type \texttt{Tx}, initialized
     with \texttt{x}.
   \item generate implemented getter method:
       \begin{lstlisting}
           public Tx x() { return _x; }
       \end{lstlisting}
   \end{itemize}

\item For methods inside the interface with the form \texttt{void x(Tx x)}:
  \begin{itemize}
    \item check if exist method \texttt{Tx x()}. If not, generate error.
    \item generate implemented setter method:
       \begin{lstlisting}
           pubic void x(Tx x) { this.x = x; }
       \end{lstlisting}
    \end{itemize}

\item For methods with the form \texttt{T withX(Tx \_)}:
  \begin{itemize}
  \item if there is no \texttt{x} field, or type \texttt{Tx} does not match,
    then generate error.
  \item implement `withX` using the `of` method.
  \end{itemize}

\item For methods with the form of \texttt{T clone()}: Use \texttt{of} method as
  the constructor, to create a new object with the same field values as the
  current one.

\item For methods with the form of \texttt{T x(Tx \_)}:
  \begin{itemize}
    \item check if exist method \texttt{T x()}, if not, generate error.
    \item inside the inner class, generate
      \begin{lstlisting}
          pubic T x(Tx x) { this.x = x; return this;}
      \end{lstlisting}
  \end{itemize}
\end{itemize}

Another advantage: multiple inheritance.

\lstinputlisting[linerange=46-52]{../UseMixinLombok/src/test/TestAnimal.java}% APPLY:linerange=POINT2D

\lstinputlisting[linerange=56-60]{../UseMixinLombok/src/test/TestAnimal.java}% APPLY:linerange=POINT3D

\lstinputlisting[linerange=64-67]{../UseMixinLombok/src/test/TestAnimal.java}% APPLY:linerange=ANIMAL

\lstinputlisting[linerange=71-76]{../UseMixinLombok/src/test/TestAnimal.java}% APPLY:linerange=HORSE

\lstinputlisting[linerange=80-92]{../UseMixinLombok/src/test/TestAnimal.java}% APPLY:linerange=BIRD

\lstinputlisting[linerange=96-97]{../UseMixinLombok/src/test/TestAnimal.java}% APPLY:linerange=PEGASUS

Interface \texttt{Point3D} extends \texttt{Point/Point2D} with a new abstract
method \texttt{int z()} (treated as a getter for member field
\texttt{z}). Interface \texttt{Horse} shows the usage and advantage of
\emph{with} methods by method \texttt{run()}: method \texttt{withX} returns a
new point object with field \texttt{x} updated by the argument to
\texttt{withX}. Without these \texttt{with} methods, operations like
\texttt{run()} would be much harder to define. Note that the return type of
various methods get refined automatically by our annotation processor. Besides
\emph{with}, other methods (including \emph{clone}, \emph{of}) also do
type-refinements automatically.

The \emph{``multiple inheritance''} case appears at interface
\texttt{Pegasus}. Pegasuses can not only \emph{run} but also \emph{fly}!
Interface \texttt{Pegasus} obtains \texttt{fly} and \texttt{run} functionality
through interface \texttt{Horse} and \texttt{Bird}. Using \mixin annotation,
actually these is no code at all programmers have to write. The idea of using
default methods inside interfaces was proposed in ~\cite{}. It enables us to do
multiple inheritance, which otherwise is hard to do in Java-like languages that
do not support multiple inheritance, easily.
